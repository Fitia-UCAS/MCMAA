目录结构:
|-- 文件: app.log
|-- 文件夹: build
|   |-- (空目录)
|-- 文件夹: controller
|   |-- 文件: workbench_controller.py
|-- 文件: main.py
|-- 文件: main.spec
|-- 文件: mcmaa.icns
|-- 文件: mcmaa.ico
|-- 文件: mcmaa.png
|-- 文件夹: model
|   |-- 文件: latex_extractor.py
|   |-- 文件: text_replacer.py
|-- 文件: pyinstaller.txt
|-- 文件: requirements.txt
|-- 文件夹: service
|   |-- 文件夹: agents
|   |   |-- 文件: backend_client.py
|   |   |-- 文件: mathmodelagent_client.py
|-- 文件夹: utils
|   |-- 文件夹: ai-aid-mcmaa
|   |   |-- 文件: 1.摘要.txt
|   |   |-- 文件: 2.问题重述.txt
|   |   |-- 文件: 3.问题分析.txt
|   |   |-- 文件: 4.模型假设.txt
|   |   |-- 文件: 5.符号说明.txt
|   |   |-- 文件: 6.1模型建立与求解.txt
|   |   |-- 文件: 6.2模型建立与求解.txt
|   |   |-- 文件: 6.3模型建立与求解.txt
|   |   |-- 文件: 6.4模型建立与求解.txt
|   |   |-- 文件: 6.5模型建立与求解.txt
|   |   |-- 文件: 7.模型评价.txt
|   |   |-- 文件: 8.细化求解结果及分析.txt
|   |-- 文件: aid_loader.py
|   |-- 文件: clear_pycache.py
|   |-- 文件: contents.py
|   |-- 文件: paths.py
|   |-- 文件: 提示词.md
|   |-- 文件: 论文架构.txt
|   |-- 文件: 调试流程.txt
|-- 文件夹: view
|   |-- 文件: common_widgets.py
|   |-- 文件: config.py
|   |-- 文件夹: screens
|   |   |-- 文件: screen_workbench.py
|   |   |-- 文件: __init__.py
|   |-- 文件: __init__.py


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\main.py 的内容:
================================================================================
# %% main.py
# -*- coding: utf-8 -*-

# 内置库
import os
import sys
import logging
from logging.handlers import RotatingFileHandler
from tkinter import Toplevel
import tkinter.messagebox as messagebox

# 第三方库
import ttkbootstrap as ttk
from tkinterdnd2 import TkinterDnD, DND_FILES

from view.config import DATA_CONFIG, SCREEN_CONFIG
from view.screens.screen_workbench import Screen_Workbench
from utils.clear_pycache import clear_pycache
from utils.paths import resource_path

# （可选）Windows 高 DPI 感知，减少缩放造成的“看起来偏一点”
try:
    if sys.platform.startswith("win"):
        import ctypes  # noqa: F401

        ctypes.windll.shcore.SetProcessDpiAwareness(1)  # PER_MONITOR_AWARE
except Exception:
    pass

# ========== 日志 ==========
logger = logging.getLogger()
logger.setLevel(logging.INFO)
_handler = RotatingFileHandler("app.log", mode="a", maxBytes=2 * 1024 * 1024, backupCount=3, encoding="utf-8")
_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
_handler.setFormatter(_formatter)
logger.handlers = [_handler]


# 捕获未处理异常：写日志 + 弹窗提示
def _excepthook(exc_type, exc, tb):
    logging.exception("Uncaught exception", exc_info=(exc_type, exc, tb))
    try:
        messagebox.showerror("错误", f"发生未处理异常：{exc_type.__name__}: {exc}")
    except Exception:
        pass


sys.excepthook = _excepthook


# 统一的“实际尺寸后再居中”函数
def center_window(win):
    """
    把顶层窗口居中到屏幕（考虑 DPI/装饰边距）。
    必须在 win.update_idletasks() 之后调用更准确。
    """
    try:
        win.update_idletasks()
        sw, sh = win.winfo_screenwidth(), win.winfo_screenheight()
        # 已布局后的真实尺寸；若为 1，再退回到需求尺寸
        w = win.winfo_width() or win.winfo_reqwidth()
        h = win.winfo_height() or win.winfo_reqheight()
        # 防止超过屏幕
        w = min(w, sw)
        h = min(h, sh)
        x = max((sw - w) // 2, 0)
        y = max((sh - h) // 2, 0)
        win.geometry(f"{w}x{h}+{x}+{y}")
    except Exception:
        pass


# ========== 启动画面（ASCII Splash）==========
ASCII_MCMAA = r"""
        ,'  , `.  ,----..          ,'  , `.   ,---,         ,---,        
     ,-+-,.' _ | /   /   \      ,-+-,.' _ |  '  .' \       '  .' \       
  ,-+-. ;   , |||   :     :  ,-+-. ;   , || /  ;    '.    /  ;    '.     
 ,--.'|'   |  ;|.   |  ;. / ,--.'|'   |  ;|:  :       \  :  :       \    
|   |  ,', |  ':.   ; /--` |   |  ,', |  '::  |   /\   \ :  |   /\   \   
|   | /  | |  ||;   | ;    |   | /  | |  |||  :  ' ;.   :|  :  ' ;.   :  
'   | :  | :  |,|   : |    '   | :  | :  |,|  |  ;/  \   \  |  ;/  \   \ 
;   . |  ; |--' .   | '___ ;   . |  ; |--' '  :  | \  \ ,'  :  | \  \ ,' 
|   : |  | ,    '   ; : .'||   : |  | ,    |  |  '  '--' |  |  '  '--'   
|   : '  |/     '   | '/  :|   : '  |/     |  :  :       |  :  :         
;   | |`-'      |   :    / ;   | |`-'      |  | ,'       |  | ,'         
|   ;/           \   \ .'  |   ;/          `--''         `--''           
'---'             `---`    '---'                                         
"""


class Splash(Toplevel):
    def __init__(self, master, delay_ms=1200):
        super().__init__(master)
        # 无边框置顶
        self.overrideredirect(True)
        self.attributes("-topmost", True)

        # 内容
        frame = ttk.Frame(self, padding=24)
        frame.pack(fill="both", expand=True)
        # 使用等宽字体以显示 ASCII
        label = ttk.Label(frame, text=ASCII_MCMAA, font=("Consolas", 12), justify="left")
        label.pack()

        # 居中（基于实际大小）
        self.update_idletasks()
        center_window(self)

        # 延时关闭
        self.after(delay_ms, self.destroy)


# ========== 主屏 ==========
class Screen(ttk.Frame):
    """唯一主界面：写作工作台"""

    def __init__(self):
        super().__init__(DATA_CONFIG["window"], **SCREEN_CONFIG)
        DATA_CONFIG["screen"] = self
        self.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 直接加载合并后的工作台
        self.workbench = Screen_Workbench(self)
        # 给“同步预览”留一个开关（目前工作台始终同步，后续可在 set_preview 里读取此值）
        self.workbench.sync_preview = True
        self.workbench.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 菜单栏
        self._build_menubar()

    # ---------- 顶部极简菜单 ----------
    def _build_menubar(self):
        root = DATA_CONFIG["window"]
        menubar = ttk.Menu(root)

        # File
        m_file = ttk.Menu(menubar, tearoff=False)
        m_file.add_command(label="Open\tCtrl+O", command=self.workbench.select_file)
        m_file.add_command(label="Save\tCtrl+S", command=self.workbench.save_current_text)
        m_file.add_command(label="Reload", command=self.workbench.reload_from_disk)
        m_file.add_separator()

        # Quick Open 子菜单：用 postcommand 动态刷新
        self.quick_open_menu = ttk.Menu(m_file, tearoff=False, postcommand=self._refresh_quick_open)
        m_file.add_cascade(label="Quick Open", menu=self.quick_open_menu)

        menubar.add_cascade(label="File", menu=m_file)

        # View
        m_view = ttk.Menu(menubar, tearoff=False)
        self._sync_preview_var = ttk.BooleanVar(value=True)

        def _toggle_sync():
            # 目前 set_preview 会自动切换到“预览”，这里仅保存偏好，便于将来生效
            self.workbench.sync_preview = bool(self._sync_preview_var.get())

        m_view.add_checkbutton(
            label="Sync Preview", onvalue=True, offvalue=False, variable=self._sync_preview_var, command=_toggle_sync
        )
        menubar.add_cascade(label="View", menu=m_view)

        # Help
        m_help = ttk.Menu(menubar, tearoff=False)
        m_help.add_command(label="View Log", command=self._show_log_window)
        m_help.add_separator()
        m_help.add_command(label="About", command=self._about)
        menubar.add_cascade(label="Help", menu=m_help)

        root.config(menu=menubar)

    def _refresh_quick_open(self):
        # 先清空
        self.quick_open_menu.delete(0, "end")
        paths = self.workbench.get_recent_files()
        if not paths:
            self.quick_open_menu.add_command(label="(Empty)", state="disabled")
            return
        for p in paths:
            self.quick_open_menu.add_command(label=p, command=lambda _p=p: self.workbench.quick_open(_p))

    def _show_log_window(self):
        log_path = os.path.join(DATA_CONFIG.get("py_path") or ".", "app.log")
        try:
            with open(log_path, "r", encoding="utf-8") as f:
                content = f.read()
        except Exception as e:
            content = f"(无法读取日志: {e})"

        win = ttk.Toplevel(self)
        win.title("应用日志 app.log")
        win.geometry("900x600")
        txt = ttk.ScrolledText(win, wrap="word", state="normal")
        txt.pack(fill="both", expand=True)
        txt.insert("end", content)
        txt.config(state="disabled")

    def _about(self):
        messagebox.showinfo(
            "About",
            "MCM Aid Assistant v1.1.0\n\n"
            "极简写作工作台：左侧大纲/问题树，右侧编辑/预览/标记替换。\n"
            "快捷键：Ctrl+O 打开，Ctrl+S 保存，Ctrl+F 查找，Ctrl+H 替换。\n"
            "File→Quick Open 提供最近文件。",
        )



class App:
    """应用主体"""

    def __init__(self, py_path=os.path.dirname(os.path.abspath(__file__))):
        DATA_CONFIG["app"] = self
        DATA_CONFIG["py_path"] = py_path

        # 使用支持拖拽的 Tk 根窗口，然后套用 ttkbootstrap 的主题
        root = TkinterDnD.Tk()
        root.withdraw()
        root.title("数学建模论文写作辅助软件 MCM Aid Assistant v1.1.0")
        ttk.Style(theme="sandstone")  # 应用主题到当前 Tk

        DATA_CONFIG["window"] = root

        # 图标
        try:
            if sys.platform.startswith("darwin"):
                root.iconphoto(True, ttk.PhotoImage(file=resource_path("mcmaa.png")))
            else:
                # Linux 用 iconphoto，更通用；Windows 可留 iconbitmap
                ico_path = resource_path("mcmaa.ico")
                if sys.platform.startswith("win"):
                    root.iconbitmap(ico_path)
                else:
                    root.iconphoto(True, ttk.PhotoImage(file=resource_path("mcmaa.png")))
        except Exception as e:
            logging.info(f"图标加载失败: {e}")


        # ========== 尺寸 ==========
        min_height = 960
        min_width = int(min_height * 4 / 3)
        root.minsize(min_width, min_height)

        screen_height = root.winfo_screenheight()
        screen_width = root.winfo_screenwidth()

        # 建议默认窗口为屏幕高的 75%，并按 4:3 比例
        default_height = int(screen_height * 0.75)
        default_width = int(default_height * 4 / 3)

        # 如果屏幕太小，就退回到屏幕实际大小
        if screen_height < min_height or screen_width < min_width:
            default_height = min(screen_height, min_height)
            default_width = min(screen_width, min_width)

        # —— 一次性设置大小 + 初步居中（基于估算尺寸）
        x = max((screen_width - default_width) // 2, 0)
        y = max((screen_height - default_height) // 2, 0)
        root.geometry(f"{default_width}x{default_height}+{x}+{y}")

        # ========== 显示启动 ASCII Splash ==========
        splash = Splash(root, delay_ms=1200)

        # Splash 消失后显示主界面
        def _show_main():
            if splash.winfo_exists():
                try:
                    splash.destroy()
                except Exception:
                    pass
            root.deiconify()
            Screen()  # 创建主界面
            # 关键：内容绘制完成后再按“实际尺寸”精确居中一次
            center_window(root)

        root.after(1250, _show_main)  # 稍微比 Splash 多 50ms，避免闪烁
        root.mainloop()


if __name__ == "__main__":
    App()
    script_dir = os.path.dirname(os.path.abspath(__file__))
    clear_pycache(script_dir)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\main.spec 的内容:
================================================================================
# -*- mode: python ; coding: utf-8 -*-

a = Analysis(
    ['main.py'],
    pathex=['.'],
    binaries=[],
    # 把整个目录打包进去：递归复制到运行时同名目录
    datas=[
        ('mcmaa.ico', '.'),
        ('utils/ai-aid-mcmaa', 'utils/ai-aid-mcmaa'),
    ],
    hiddenimports=[],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='main',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
    icon=['mcmaa.ico'],
)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\controller\workbench_controller.py 的内容:
================================================================================
# %% controller/workbench_controller.py
# -*- coding: utf-8 -*-

"""
AgentBridge — 适配 MathModelAgent 的两段式客户端（HTTP 提交 + WS 订阅）
------------------------------------------------------------------
- agent_connect(base_url, ws_base, ...): 仅初始化客户端，不立刻连 WS
- agent_submit_and_connect(...): HTTP 提交建模 -> 获得 task_id -> 连接该任务的 WS
- agent_connect_task(task_id): 已有 task_id 时，直接连该任务的 WS
- agent_close(): 断开
- agent_send_json(): 若后端/客户端支持任务流上的下行消息，则可发送；多数部署会不支持
- agent_request(): 标记为不支持（raise NotImplementedError）

保留：
- set_agent_handlers(on_status/on_message/on_error)
- 最近消息缓存、状态/错误查询
"""
from __future__ import annotations

from pathlib import Path
from typing import Any, Callable, Deque, Dict, Optional, Iterable, Tuple, List
from collections import deque
import logging
import ssl
import time

from service.agents.mathmodelagent_client import MathModelAgentClient
from utils.aid_loader import list_aid_files

logger = logging.getLogger(__name__)


class AgentBridge:
    """为控制器提供与 Agent 的连接/通信能力（Mixin）。"""

    # WS 任务流路径模板（按你的后端路由改这里即可）
    WS_TASK_PATH_TPL = "/ws/tasks/{task_id}"

    # ------------------------ 生命周期 / 状态 ------------------------
    def __init__(self) -> None:
        # 运行态
        self._agent: Optional[MathModelAgentClient] = None
        self._agent_connected: bool = False
        self._agent_last_status: str = "disconnected"
        self._agent_last_error: Optional[str] = None
        self._agent_msgs: Deque[Any] = deque(maxlen=200)

        # 任务态
        self._current_task_id: Optional[str] = None
        self._base_url: Optional[str] = None
        self._ws_base: Optional[str] = None
        self._token: Optional[str] = None
        self._proxy: Optional[str] = None

        # 回调（由 View 注入）
        self._cb_on_status: Optional[Callable[[str], None]] = None
        self._cb_on_message: Optional[Callable[[Any], None]] = None
        self._cb_on_error: Optional[Callable[[str], None]] = None

    # ------------------------ 回调注册 ------------------------
    def set_agent_handlers(
        self,
        on_status: Optional[Callable[[str], None]] = None,
        on_message: Optional[Callable[[Any], None]] = None,
        on_error: Optional[Callable[[str], None]] = None,
    ) -> None:
        self._cb_on_status = on_status
        self._cb_on_message = on_message
        self._cb_on_error = on_error

    # ------------------------ 连接管理（初始化阶段） ------------------------
    def agent_connect(
        self,
        base_url: str,
        ws_base: Optional[str] = None,
        token: Optional[str] = None,
        proxy: Optional[str] = None,
        ping_interval: float = 20.0,
        insecure_skip_tls_verify: bool = False,
    ) -> None:
        """
        初始化客户端（不立刻建立 WS 连接）。
        - base_url: HTTP 基地址，如 http://127.0.0.1:8000
        - ws_base:  WS 基地址，如 ws://127.0.0.1:8000；不传则由 base_url 推断
        """
        self.agent_close()

        self._base_url = base_url.strip().rstrip("/")
        self._ws_base = (ws_base or "").strip().rstrip("/") or None
        self._token = (token or "").strip() or None
        self._proxy = (proxy or "").strip() or None

        sslopt = {"cert_reqs": ssl.CERT_NONE} if insecure_skip_tls_verify else None
        self._agent = MathModelAgentClient(
            base_url=self._base_url,
            ws_base=self._ws_base,
            token=self._token,
            proxy=self._proxy,
            ping_interval=ping_interval,
            sslopt=sslopt,
        )

        # 绑定底层回调（这些回调在 WS 线程里触发；若要切 UI 线程请在 View 层 after）
        @self._agent.on_open
        def _opened():
            self._agent_connected = True
            self._set_status("connected")

        @self._agent.on_message
        def _message(m):
            self._agent_msgs.append({"ts": time.time(), "data": m})
            if self._cb_on_message:
                try:
                    self._cb_on_message(m)
                except Exception as e:  # noqa
                    logger.debug("on_message UI cb error: %s", e)

        @self._agent.on_error
        def _error(e: Exception):
            self._agent_last_error = str(e)
            self._set_status("error")
            if self._cb_on_error:
                try:
                    self._cb_on_error(self._agent_last_error)
                except Exception:  # noqa
                    pass

        @self._agent.on_close
        def _closed(code: int, msg: str):
            self._agent_connected = False
            self._set_status(f"closed({code})")

        @self._agent.on_reconnect
        def _reconn(attempt: int, delay: float):
            self._set_status(f"reconnecting #{attempt} in {delay:.1f}s")

        # 仅初始化，不连 WS
        self._current_task_id = None
        self._set_status("ready")

    # ------------------------ 提交并连接（推荐流程） ------------------------
    def agent_submit_and_connect(
        self,
        problem_text: str,
        files: Optional[Iterable[Tuple[str, Tuple[str, Any, str]]]] = None,
        template: str = "mcm",
        output_format: str = "latex",
        language: str = "zh",
        extra_form: Optional[Dict[str, Any]] = None,
        timeout: float = 60.0,
    ) -> str:
        """
        1) HTTP 提交建模 -> 获得 task_id（从 JSON 中提取）
        2) 连接该 task 的 WS 流（后台线程）
        :return: task_id
        """
        if not self._agent:
            raise RuntimeError("agent is not initialized, call agent_connect(base_url, ...) first")

        # --- 构造 payload（JSON 方式） ---
        payload = {
            "problem_text": problem_text,
            "template": template,
            "output_format": output_format,
            "language": language,
            "extra_form": extra_form or {},
            "timeout": timeout,
            # 如需传文件且后端只收 JSON，可将 files 转成 base64 后放入自定义字段
            # "files": [...],
        }

        self._set_status("submitting...")
        resp = self._agent.submit_modeling(payload)  # -> Dict

        # --- 提取 task_id（兼容常见返回结构） ---
        task_id = (
            (resp.get("task_id"))
            or (isinstance(resp.get("data"), dict) and resp["data"].get("task_id"))
            or resp.get("id")
        )
        if not task_id:
            raise RuntimeError(f"submit response missing task_id: {resp!r}")

        self._current_task_id = str(task_id)

        # --- 连接任务 WS ---
        self._set_status(f"connecting task {self._current_task_id}...")
        ws_path = self.WS_TASK_PATH_TPL.format(task_id=self._current_task_id)
        self._agent.connect_ws(path=ws_path, block=False)
        return self._current_task_id

    # ------------------------ 已有 task_id 时直接连接 ------------------------
    def agent_connect_task(self, task_id: str) -> None:
        """
        已有 task_id（例如从历史记录拿到）时，直接连接该任务的 WS。
        """
        if not self._agent:
            raise RuntimeError("agent is not initialized, call agent_connect(base_url, ...) first")
        self._current_task_id = task_id.strip()
        self._set_status(f"connecting task {self._current_task_id}...")
        ws_path = self.WS_TASK_PATH_TPL.format(task_id=self._current_task_id)
        self._agent.connect_ws(path=ws_path, block=False)

    # ------------------------ 断开 ------------------------
    def agent_close(self) -> None:
        if self._agent:
            try:
                self._agent.close()
            except Exception:  # noqa
                pass
            finally:
                self._agent = None
        self._agent_connected = False
        self._current_task_id = None
        self._set_status("disconnected")

    def agent_is_connected(self) -> bool:
        return bool(self._agent and self._agent.is_connected())

    # ------------------------ 发送 API（多数后端不支持） ------------------------
    def agent_send_text(self, text: str) -> None:
        """
        若底层客户端实现了 send_text，则透传；否则抛出“不支持”。
        注意：MathModelAgent 的任务 WS 通道通常为只读流。
        """
        if not self._agent:
            raise RuntimeError("agent not connected")
        if not hasattr(self._agent, "send_text"):
            raise NotImplementedError("current backend does not accept client->server messages on task stream")
        self._agent.send_text(text)  # type: ignore[attr-defined]

    def agent_send_json(self, payload: Dict[str, Any]) -> None:
        """
        同上：若后端开放了任务通道指令，且客户端实现了 send_json，这里才可用。
        """
        if not self._agent:
            raise RuntimeError("agent not connected")
        if not hasattr(self._agent, "send_json"):
            raise NotImplementedError("current backend does not accept JSON messages on task stream")
        # 有些后端会要求附带 task_id；如需可在此注入 payload["task_id"] = self._current_task_id
        self._agent.send_json(payload)  # type: ignore[attr-defined]

    def agent_request(self, payload: Dict[str, Any], timeout: float = 15.0) -> Any:
        """
        经典“请求-响应”模式对任务流通常不适用，这里明确不支持。
        如果未来后端提供 request_id 语义，可在底层客户端实现后再开放。
        """
        raise NotImplementedError("request/response is not supported on the task WebSocket stream")

    # ------------------------ 消息缓存（可选给 View 拉取） ------------------------
    def agent_recent_messages(self, limit: int = 50) -> list[Any]:
        """返回最近收到的消息（新 → 旧）。"""
        out = list(self._agent_msgs)
        out.reverse()
        return out[:limit]

    def agent_last_error(self) -> Optional[str]:
        return self._agent_last_error

    def agent_status(self) -> str:
        return self._agent_last_status

    # ------------------------ 内部：状态 & 回调封装 ------------------------
    def _set_status(self, status: str) -> None:
        self._agent_last_status = status
        if self._cb_on_status:
            try:
                self._cb_on_status(status)
            except Exception:  # noqa
                pass


"""
WorkbenchController
===================

将“处理逻辑/业务逻辑”集中到 Controller，View 只负责显示与事件绑定。

职责边界：
- Controller 负责：文件读写、最近文件管理、LatexExtractor 构建与数据整形、
  标记对扫描与替换、辅助文本读取、纯内容片段提取（不含展示性分隔与文案）。
- View 负责：控件创建、布局、事件绑定、把用户输入/当前文本传给 Controller，
  并根据 Controller 返回的数据刷新界面（Treeview、文本框、消息提示等），
  同时负责生成所有用户可见的文案与分隔样式。

常用调用方式（示例，文案由 View 决定）：
- 打开文件：ctrl.open_path(path)  → 返回 {"text": 文本}
- 保存文件：ctrl.save_text(current_editor_text) → (ok, msg)；ok=True 时 msg 为空字符串
- 重载文件：ctrl.reload_from_disk() → {"text": 文本}
- 构建导航树：ctrl.make_outline_nodes(ctrl.extractor)、ctrl.make_problem_tree(ctrl.extractor)、
  ctrl.make_code_nodes(ctrl.extractor)  → 交给 View 填充 Treeview
- 预览：ctrl.render_outline_preview(...), ctrl.render_problem_preview(...), ctrl.render_code_preview(...)
- 替换页：
    ctrl.update_marker_pairs_from_text(editor_text) → 返回候选显示名列表
    ctrl.get_pair_content_by_display(sel_display)  → 返回已缓存/原始内容
    ctrl.apply_replace_for_display(editor_text, sel_display, new_content) → 返回 new_text
- 辅助页：
    files = ctrl.list_aid_txt()
    txt = ctrl.read_aid_txt(filename)

备注：
- 本 Controller 维护少量状态（current_file/current_text/extractor/recent_files 等），
  但不直接操作 UI；所有需要的输入（例如“当前编辑器文本”）在调用时作为参数传入。
"""

import os
import re
import pathlib

import appdirs

from model.latex_extractor import LatexExtractor
from model.text_replacer import find_marker_pairs, replace_contents
from utils.paths import resource_path


# ===== 常量 =====
RECENT_FILE_MAX = 5
RECENT_FILE_STORE = "recent_files.txt"


class WorkbenchController(AgentBridge):
    """一体化工作台的业务控制器"""

    # ---------- 生命周期 / 状态 ----------
    def __init__(self) -> None:
        # 初始化代理桥
        AgentBridge.__init__(self)
        # 文件/文本相关
        self.current_file: Optional[str] = None
        self.current_text: str = ""
        self.extractor: Optional[LatexExtractor] = None

        # 最近文件
        self.recent_files: List[str] = self.load_recent()

        # 替换相关
        self.marker_pairs: List[Dict[str, Any]] = []
        self.replacements: Dict[int, str] = {}  # 以“标记对索引”为 key 的缓存替换文本

    # ---------- 最近文件：读写 ----------
    @staticmethod
    def _recent_store_path() -> str:
        """
        将最近文件记录存放到用户数据目录，跨平台更稳：
        Windows:  C:\\Users\\<User>\\AppData\\Local\\mcm\\mcmaa\\recent_files.txt
        macOS:    ~/Library/Application Support/mcmaa/recent_files.txt
        Linux:    ~/.local/share/mcmaa/recent_files.txt
        """
        app_dir = appdirs.user_data_dir(appname="mcmaa", appauthor="mcm")
        pathlib.Path(app_dir).mkdir(parents=True, exist_ok=True)
        return os.path.join(app_dir, RECENT_FILE_STORE)

    def load_recent(self) -> List[str]:
        path = self._recent_store_path()
        items: List[str] = []
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    p = line.strip()
                    if p and os.path.exists(p):
                        items.append(p)
        except Exception:
            pass
        return items[:RECENT_FILE_MAX]

    def save_recent(self, items: List[str]) -> None:
        path = self._recent_store_path()
        try:
            with open(path, "w", encoding="utf-8") as f:
                for p in items[:RECENT_FILE_MAX]:
                    f.write(p + "\n")
        except Exception:
            pass

    def add_recent(self, p: Optional[str]) -> None:
        """更新最近文件列表并写盘"""
        if not p:
            return
        if p in self.recent_files:
            self.recent_files.remove(p)
        self.recent_files.insert(0, p)
        self.recent_files = self.recent_files[:RECENT_FILE_MAX]
        self.save_recent(self.recent_files)

    def remove_recent_if_missing(self, p: str) -> None:
        """当文件不存在时，从最近列表清理"""
        try:
            if p in self.recent_files:
                self.recent_files.remove(p)
                self.save_recent(self.recent_files)
        except Exception:
            pass

    # ---------- 文件 I/O ----------
    @staticmethod
    def read_file(path: str) -> str:
        with open(path, "r", encoding="utf-8") as f:
            return f.read()

    @staticmethod
    def write_file(path: str, content: str) -> None:
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)

    # ---------- 打开/重载/保存：同时维护 extractor ----------
    def open_path(self, file_path: str) -> Dict[str, str]:
        """
        打开文件 -> 读取文本 -> 构建 extractor -> 维护最近文件。
        仅返回内容，不返回面向用户的 UI 文案。
        返回 {"text": 文本}
        """
        self.current_file = file_path
        text = self.read_file(file_path)
        self.current_text = text
        self.extractor = self.build_extractor(file_path, max_level=3)
        self.add_recent(file_path)
        # 开启新文件后，清空替换缓存 & 重新扫描标记
        self.replacements.clear()
        self.update_marker_pairs_from_text(text)
        return {"text": text}

    def reload_from_disk(self) -> Dict[str, str]:
        """
        从磁盘重载当前文件，不改动磁盘文件，只更新内存文本与 extractor。
        返回 {"text": 文本}（不返回 UI 文案）
        """
        if not self.current_file:
            return {"text": ""}
        text = self.read_file(self.current_file)
        self.current_text = text
        self.extractor = self.build_extractor(self.current_file, max_level=3)
        # 保持替换缓存策略简单：重载时清空，避免索引错位
        self.replacements.clear()
        self.update_marker_pairs_from_text(text)
        return {"text": text}

    def save_text(self, editor_text: str) -> Tuple[bool, str]:
        """
        保存编辑器文本到当前文件，并重建 extractor。
        成功时返回 (True, "") —— 留空文案交由 View 决定；
        失败时返回 (False, 技术错误字符串) —— 由 View 决定如何组织对用户的提示。
        """
        if not self.current_file:
            return False, "no file opened"
        try:
            self.write_file(self.current_file, editor_text)
            self.current_text = editor_text
            self.extractor = self.build_extractor(self.current_file, max_level=3)
            self.add_recent(self.current_file)
            # 保存后不强制清空 replacements；索引变化会在下一次扫描时自然覆盖
            self.update_marker_pairs_from_text(editor_text)
            return True, ""  # 文案交由 View
        except Exception as e:
            return False, str(e)  # 技术信息，非 UI 文案

    # ---------- 模型 ----------
    @staticmethod
    def build_extractor(tex_path: str, max_level: int = 3) -> LatexExtractor:
        return LatexExtractor(tex_path, max_level=max_level)

    # ---------- 导航树数据（仅数据组装，View 自行渲染） ----------
    @staticmethod
    def make_outline_nodes(extractor: Optional[LatexExtractor]) -> List[Dict[str, Any]]:
        """
        生成大纲节点数据（不含 codeblock）：
        返回列表，每个元素：{"title": str, "level": int, "line_num": int}
        视图侧按 level 构建层级关系。
        """
        nodes: List[Dict[str, Any]] = []
        if not extractor:
            return nodes
        for section_type, title, level, line_num in extractor.sections:
            if section_type == "codeblock":
                continue
            nodes.append({"title": title, "level": level, "line_num": line_num})
        return nodes

    @staticmethod
    def make_problem_tree(extractor: Optional[LatexExtractor]) -> List[Dict[str, Any]]:
        """
        生成问题树数据（结构化数据，文案与展示由 View 决定）：
        返回：
        [
          {"text": f"问题{k}", "values": (k,), "children": [
                {"text":"摘要片段", "values":(k, "abstract")},
                {"text":"问题重述","values":(k, "restate")},
                {"text":"问题分析","values":(k, "analysis")},
                {"text":"模型与求解","values":(k, "modeling")},
          ]},
          ...
        ]
        """
        items: List[Dict[str, Any]] = []
        if not extractor:
            return items
        try:
            keywords = extractor.get_unique_keywords()
        except Exception:
            keywords = []
        for k in keywords:
            node = {
                "text": f"问题{k}",
                "values": (k,),
                "children": [
                    {"text": "摘要片段", "values": (k, "abstract")},
                    {"text": "问题重述", "values": (k, "restate")},
                    {"text": "问题分析", "values": (k, "analysis")},
                    {"text": "模型与求解", "values": (k, "modeling")},
                ],
            }
            items.append(node)
        return items

    @staticmethod
    def make_code_nodes(extractor: Optional[LatexExtractor]) -> List[Dict[str, Any]]:
        """
        生成代码树节点数据（只列出 codeblock，保持出现顺序）：
        返回列表，每个元素：{"text": title, "values": (start_line, 4)}
        """
        nodes: List[Dict[str, Any]] = []
        if not extractor:
            return nodes
        for cb in extractor.codeblocks:
            nodes.append({"text": cb["title"], "values": (cb["start"], 4)})
        return nodes

    # ---------- 预览渲染（仅内容拼接，不做展示性分隔） ----------
    @staticmethod
    def render_outline_preview(
        extractor: Optional[LatexExtractor],
        start_line: int,
        start_level: int,
    ) -> str:
        """大纲点击后的预览：从起始行到下一个同级/更高级标题"""
        if not extractor:
            return ""
        lines = extractor.extract_content(start_line, start_level)
        return "\n".join(lines)

    def render_code_preview(
        self,
        extractor: Optional[LatexExtractor],
        start_line: int,
        level: int,
    ) -> str:
        """代码树点击后的预览：直接复用提取"""
        return self.render_outline_preview(extractor, start_line, level)

    @staticmethod
    def render_problem_preview(
        extractor: Optional[LatexExtractor],
        k: str,
        part: Optional[str] = None,
    ) -> str:
        """
        问题树项点击后的预览：
        - part 为 None：合并“摘要片段/重述/分析/建模”，不插入展示性分隔，交由 View 决定呈现样式
        - part in {"abstract","restate","analysis","modeling"}：只返回对应部分
        """
        if not extractor or not k:
            return ""
        parts = extractor.extract_problem_parts(k)
        abstract = extractor.extract_abstract_parts(k)

        if part is None:
            merged: List[str] = []
            if abstract:
                merged += abstract + [""]

            if "Restatement" in parts:
                merged += parts["Restatement"] + [""]

            if "Analysis" in parts:
                merged += parts["Analysis"] + [""]

            if "Modeling" in parts:
                merged += parts["Modeling"] + [""]

            return "\n".join(merged).strip() or ""

        # 单部分
        if part == "abstract":
            content = abstract
        elif part == "restate":
            content = parts.get("Restatement", [])
        elif part == "analysis":
            content = parts.get("Analysis", [])
        elif part == "modeling":
            content = parts.get("Modeling", [])
        else:
            content = []
        return "\n".join(content).strip()

    # ---------- 复制文本（供 View 放入剪贴板，保持纯内容） ----------
    @staticmethod
    def build_problem_merged_text(extractor: Optional[LatexExtractor], k: str) -> str:
        if not extractor or not k:
            return ""
        parts = extractor.extract_problem_parts(k)
        abstract = extractor.extract_abstract_parts(k)

        merged: List[str] = []
        if abstract:
            merged += abstract + [""]

        if "Restatement" in parts:
            merged += parts["Restatement"] + [""]

        if "Analysis" in parts:
            merged += parts["Analysis"] + [""]

        if "Modeling" in parts:
            merged += parts["Modeling"] + [""]

        return "\n".join(merged).strip()

    @staticmethod
    def build_problem_part_text(extractor: Optional[LatexExtractor], k: str, part: str) -> str:
        if not extractor or not k:
            return ""
        if part == "abstract":
            content = extractor.extract_abstract_parts(k)
        else:
            mapping = {"restate": "Restatement", "analysis": "Analysis", "modeling": "Modeling"}
            pieces = extractor.extract_problem_parts(k)
            content = pieces.get(mapping.get(part, ""), [])
        return "\n".join(content).strip()

    # ---------- 替换功能 ----------
    @staticmethod
    def _marker_display_name(marker_type: str) -> str:
        """
        将 “<----- xxx ----->” 提取为 “xxx”；若不匹配则返回原串。
        """
        m = re.search(r"<-----(.*?)----->", marker_type)
        return m.group(1).strip() if m else marker_type

    def update_marker_pairs_from_text(self, text: str) -> List[str]:
        """
        扫描标记对，更新 self.marker_pairs，并返回“可供下拉选择的显示名列表”。
        注意：下拉项可能不唯一（如果模板里有相同的 marker_type），此处保持与旧实现一致。
        """
        self.marker_pairs = find_marker_pairs(text)
        display = [self._marker_display_name(p["marker_type"]) for p in self.marker_pairs]
        return display

    def get_pair_content_by_display(self, display_name: str) -> str:
        """
        根据显示名找到对应标记对，返回“已缓存替换文本”或“原始内容”。
        规则与原实现一致：优先返回 self.replacements[idx]，否则返回 pair["content"]。
        """
        display_name = (display_name or "").strip()
        if not display_name:
            return ""
        for pair in self.marker_pairs:
            disp = self._marker_display_name(pair["marker_type"])
            if disp == display_name:
                idx = pair["index"]
                return self.replacements.get(idx, pair.get("content", ""))
        return ""

    def apply_replace_for_display(self, base_text: str, display_name: str, new_content: str) -> str:
        """
        对“当前选择的标记对”应用替换，返回新的整篇文本（View 写回到编辑器即可）。
        - base_text：通常是编辑器里的完整文本
        - display_name：下拉选中的项（例如 “摘要/关键词/引言” 等）
        - new_content：替换区域的完整新文本
        """
        display_name = (display_name or "").strip()
        if not display_name:
            return base_text

        # 1) 通过显示名定位 index
        idx: Optional[int] = None
        for pair in self.marker_pairs:
            disp = self._marker_display_name(pair["marker_type"])
            if disp == display_name:
                idx = pair["index"]
                break
        if idx is None:
            return base_text

        # 2) 记录到缓存并做整体替换
        self.replacements[idx] = new_content
        new_text = replace_contents(base_text, self.replacements)

        # 3) 替换后重新扫描标记对（索引可能重排）
        self.update_marker_pairs_from_text(new_text)
        return new_text

    # ---------- 辅助页 ----------
    @staticmethod
    def aid_dir() -> str:
        """
        返回 utils/ai-aid-mcmaa 目录（支持 pyinstaller 后的资源路径）
        """
        return resource_path("utils", "ai-aid-mcmaa")

    def list_aid_txt(self) -> List[str]:
        d = self.aid_dir()
        logging.info("AID_DIR=%s exists=%s", d, os.path.isdir(d))
        out: List[str] = []
        try:
            if os.path.isdir(d):
                for name in os.listdir(d):
                    if name.lower().endswith(".txt"):
                        out.append(name)
        except Exception:
            pass
        out.sort()
        return out

    def read_aid_txt(self, filename: str) -> str:
        fpath = os.path.join(self.aid_dir(), filename)
        with open(fpath, "r", encoding="utf-8") as f:
            return f.read()

    # ---------- Quick Open：供菜单调用 ----------
    def quick_open(self, p: Optional[str]) -> Tuple[bool, str, str]:
        """
        给“Quick Open”使用：
        - 路径为空或文件不存在：返回 (False, 技术原因字符串, "")
        - 成功：等价于 open_path，返回 (True, "", text)
        （不返回 UI 文案，由 View 决定展示“文件已加载: ...”等）
        """
        if not p or not os.path.exists(p):
            self.remove_recent_if_missing(p or "")
            return False, "file not found or removed", ""
        data = self.open_path(p)
        return True, "", data.get("text", "")

    # ---------- 工具：将 Editor 的文本更新到 Controller（不保存磁盘） ----------
    def update_current_text_only(self, editor_text: str) -> None:
        """
        View 在需要时可以调用该方法同步“当前编辑器内容”到 Controller。
        注意：该方法不会写入磁盘，也不会重建 extractor。
        主要用于替换页/辅助页等需要 Controller 暂存当前文本参与计算的场景。
        """
        self.current_text = editor_text

    def get_aid_choices(self):
        """下拉：返回显示名列表"""
        return [name for name, _ in list_aid_files()]

    def read_aid_file(self, display_name: str) -> str:
        """根据显示名读取文本内容"""
        for name, full in list_aid_files():
            if name == display_name:
                try:
                    return Path(full).read_text(encoding="utf-8", errors="ignore")
                except Exception:
                    # 尝试 GBK（国内文件常见）
                    return Path(full).read_text(encoding="gbk", errors="ignore")
        return ""


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\model\latex_extractor.py 的内容:
================================================================================
# %% model/latex_extractor.py
# -*- coding: utf-8 -*-

import re


class LatexExtractor:
    def __init__(self, file_path, max_level=4):
        """Initialize LaTeX extractor with file path and maximum section level"""
        self.file_path = file_path
        self.max_level = max_level
        with open(self.file_path, "r", encoding="utf-8") as file:
            self.content = file.read().splitlines()

        # 先识别 codeblock 区间，供后续解析时跳过
        self.codeblocks = self._extract_codeblocks()
        # 便于快速判断某一行是否在 codeblock 内
        self._codeblock_ranges = [(cb["start"], cb["end"]) for cb in self.codeblocks]
        # 起始行 -> 结束行 的映射（仅对 codeblock 有值）
        self._codeblock_end_by_start = {cb["start"]: cb["end"] for cb in self.codeblocks}

        # 再解析章节（会忽略 codeblock 里的 section 等）
        self.sections = self.extract_sections()

    # ---------- 基础工具 ----------

    def _in_codeblock(self, idx):
        """当前行号是否位于任意 codeblock 内"""
        for s, e in self._codeblock_ranges:
            if s <= idx <= e:
                return True
        return False

    def _strip_codeblocks(self, lines):
        """给定若干行文本，去掉 codeblock 区域内的行"""
        out = []
        in_block = False
        for line in lines:
            if (not in_block) and re.search(r"\\begin\{codeblock\}", line):
                in_block = True
                continue
            if in_block and re.search(r"\\end\{codeblock\}", line):
                in_block = False
                continue
            if not in_block:
                out.append(line)
        return out

    # ---------- 代码块解析 ----------

    def _extract_codeblocks(self):
        r"""
        识别 \begin{codeblock}[可选label]{lang} ... \end{codeblock}
        返回列表：[{index, start, end, label, lang, title}]
        其中 title 用于大纲显示，例如：'codeblock 1 [LaTeX代码]{TeX}'
        """
        blocks = []
        in_block = False
        start = -1
        label = ""
        lang = ""
        idx = 0
        counter = 0

        begin_pat = re.compile(r"\\begin\{codeblock\}(?:\[(?P<label>.*?)\])?(?:\{(?P<lang>.*?)\})?")
        end_pat = re.compile(r"\\end\{codeblock\}")

        while idx < len(self.content):
            line = self.content[idx]
            if not in_block:
                m = begin_pat.search(line)
                if m:
                    in_block = True
                    start = idx
                    label = (m.group("label") or "").strip()
                    lang = (m.group("lang") or "").strip()
            else:
                if end_pat.search(line):
                    counter += 1
                    end = idx
                    if label and lang:
                        title = f"codeblock {counter} [{label}]{{{lang}}}"
                    elif label:
                        title = f"codeblock {counter} [{label}]"
                    elif lang:
                        title = f"codeblock {counter} {{{lang}}}"
                    else:
                        title = f"codeblock {counter}"
                    blocks.append(
                        {
                            "index": counter,
                            "start": start,
                            "end": end,
                            "label": label,
                            "lang": lang,
                            "title": title,
                        }
                    )
                    in_block = False
                    start = -1
                    label = ""
                    lang = ""
            idx += 1
        return blocks

    # ---------- 章节解析（忽略 codeblock 内部） ----------

    def extract_sections(self):
        """Extract all sections including type, title, level, and line number"""
        sections = []

        # 先把每个 codeblock 当作一个虚拟 section（level=4）
        for cb in self.codeblocks:
            sections.append(("codeblock", cb["title"], 4, cb["start"]))

        section_types = {
            "section": 1,
            "subsection": 2,
            "subsubsection": 3,
            "numtitle": 4,
            "circtitle": 4,
            "dingtitle": 4,
            "squatitle": 4,
        }
        pattern = re.compile(
            r"\\(section|subsection|subsubsection|numtitle|circtitle|dingtitle|squatitle)(\[\])?\{([^\}]*)\}"
        )

        for i, raw in enumerate(self.content):
            # 跳过 codeblock 内部的任何 \section 等
            if self._in_codeblock(i):
                continue
            line = raw.strip()
            m = pattern.match(line)
            if m:
                section_type = m.group(1)
                title = m.group(3).strip()
                level = section_types[section_type]
                if level <= self.max_level:
                    sections.append((section_type, title, level, i))

        # 维持出现顺序（按照行号排序）
        sections.sort(key=lambda x: x[3])
        return sections

    # ---------- 搜索/提取 ----------

    def find_section(self, pattern):
        """Find section matching the given pattern"""
        for section in self.sections:
            if re.search(pattern, section[1]):
                return section
        return None

    def find_section_startswith(self, pattern):
        """Find section starting with the given pattern"""
        for section_type, title, level, line_num in self.sections:
            if re.match(pattern, title):
                return section_type, title, level, line_num
        return None

    def extract_content(self, start_line, start_level):
        r"""
        Extract content from start line to:
        - next section of same or higher level; or
        - if it's a codeblock item, to its \end{codeblock}
        """
        # 若这是一个 codeblock 节点，直接提取到结束
        if start_line in self._codeblock_end_by_start:
            end_line = self._codeblock_end_by_start[start_line]
            return self.content[start_line : end_line + 1]

        end_line = len(self.content)
        for _, _, level, line_num in self.sections:
            if line_num > start_line and level <= start_level:
                end_line = line_num
                break
        return self.content[start_line:end_line]

    # ---------- 业务相关：问题编号 / 摘要 / 各部分 ----------

    def get_unique_keywords(self):
        """Extract unique problem numbers from Problem Restatement section (skip codeblocks)"""
        keywords = set()
        restate_section = self.find_section(r"问题重述")
        if restate_section:
            _, _, level, line_num = restate_section
            content = self.extract_content(line_num, level)
            # 跳过 codeblock 的内容
            content = self._strip_codeblocks(content)
            pattern = re.compile(r"\\textbf\{问题([一二三四五六七八九十]+)：\}")
            for line in content:
                m = pattern.search(line)
                if m:
                    keywords.add(m.group(1))
        return sorted(list(keywords), key=self.chinese_to_number)

    def chinese_to_number(self, chinese):
        """Convert Chinese numerals to Arabic numbers for sorting"""
        num_dict = {
            "一": 1,
            "二": 2,
            "三": 3,
            "四": 4,
            "五": 5,
            "六": 6,
            "七": 7,
            "八": 8,
            "九": 9,
            "十": 10,
        }
        return num_dict.get(chinese, 0)

    def extract_abstract_parts(self, problem_num):
        """Extract abstract parts: introduction, specific problem, and summary (skip codeblocks)"""
        abstract_content = []
        intro_lines = []
        problem_lines = []
        summary_lines = []
        in_abstract = False
        target_found = False
        in_codeblock = False

        with open(self.file_path, "r", encoding="utf-8") as file:
            for raw in file:
                line = raw.strip()

                # codeblock 屏蔽
                if not in_codeblock and r"\begin{codeblock}" in line:
                    in_codeblock = True
                    continue
                if in_codeblock and r"\end{codeblock}" in line:
                    in_codeblock = False
                    continue
                if in_codeblock:
                    continue

                if r"\begin{abstract}" in line:
                    abstract_content.append(line)
                    in_abstract = True
                elif r"\end{abstract}" in line:
                    abstract_content.append(line)
                    in_abstract = False
                    break
                elif in_abstract:
                    if r"\textbf{针对问题" in line:
                        problem = re.search(r"\\textbf\{针对问题([一二三四五六七八九十]+)\}", line)
                        if problem and problem.group(1) == problem_num:
                            problem_lines.append(line)
                            target_found = True
                        elif target_found:
                            target_found = False
                    elif r"\keywords" in line:
                        summary_lines.append(line)
                        target_found = False
                    elif not problem_lines and not summary_lines:
                        intro_lines.append(line)
                    elif target_found:
                        problem_lines.append(line)
                    elif problem_lines and not target_found:
                        summary_lines.append(line)

        return abstract_content[:1] + intro_lines + problem_lines + summary_lines + abstract_content[-1:]

    def extract_problem_parts(self, problem_num):
        """Extract problem restatement, analysis, and modeling parts (skip codeblocks when scanning)"""
        parts = {}

        # Extract Problem Restatement
        restate_section = self.find_section(r"问题重述")
        if restate_section:
            _, _, level, line_num = restate_section
            content = self.extract_content(line_num, level)
            content = self._strip_codeblocks(content)
            restate_lines = [r"\section{问题重述}"]
            in_background = False
            in_restate = False
            in_target_problem = False

            for line in content:
                if r"\subsection{问题背景}" in line:
                    restate_lines.append(line)
                    in_background = True
                    in_restate = False
                elif r"\subsection{问题重述}" in line:
                    restate_lines.append(line)
                    in_background = False
                    in_restate = True
                elif f"\\textbf{{问题{problem_num}：}}" in line:
                    restate_lines.append(line)
                    in_target_problem = True
                    in_background = False
                    in_restate = False
                elif r"\textbf{问题" in line and in_target_problem:
                    in_target_problem = False
                elif in_background or in_restate or in_target_problem:
                    restate_lines.append(line)

            parts["Restatement"] = restate_lines

        # Extract Problem Analysis
        analysis_pattern = f"问题{problem_num}的分析"
        analysis_section = self.find_section(analysis_pattern)
        if analysis_section:
            section_type, title, level, line_num = analysis_section
            # 直接用章节边界提取，内部若含 codeblock 也原样返回（编辑预览更真实）
            parts["Analysis"] = [
                r"\section{问题分析}",
                f"\\{section_type}{{{title}}}",
            ] + self.extract_content(line_num + 1, level)

        # Extract Modeling and Solution
        modeling_pattern = f"问题{problem_num}模型的建立与求解"
        modeling_section = self.find_section(modeling_pattern)
        if modeling_section:
            section_type, title, level, line_num = modeling_section
            parts["Modeling"] = [
                r"\section{模型建立与求解}",
                f"\\{section_type}{{{title}}}",
            ] + self.extract_content(line_num + 1, level)

        return parts

    def extract_section(self, section_title):
        """Extract complete content of a specified top-level section"""
        for section_type, title, level, line_num in self.sections:
            if title == section_title and level == 1:
                return self.extract_content(line_num, level)
        return []

    # ---------- 保存 ----------

    def save_to_file(self, content, output_file):
        """Save content to file"""
        try:
            with open(output_file, "w", encoding="utf-8") as file:
                file.writelines(line + "\n" for line in content)
        except Exception as e:
            raise IOError(f"无法保存文件: {e}")


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\model\text_replacer.py 的内容:
================================================================================
# %% model/text_replacer.py
# -*- coding: utf-8 -*-

import re


def find_marker_pairs(text):
    marker_pattern = r"(<-----.*?----->)"
    matches = list(re.finditer(marker_pattern, text, re.DOTALL))
    if len(matches) % 2 != 0:
        print("警告：标记数量为奇数，可能存在未配对的标记。")
        return []

    marker_pairs = []
    for i in range(0, len(matches), 2):
        start_marker = matches[i]
        end_marker = matches[i + 1]
        if start_marker.group(1) != end_marker.group(1):
            print(f"警告：标记对不匹配：{start_marker.group(1)} 和 {end_marker.group(1)}")
            continue
        start_pos = start_marker.end()
        end_pos = end_marker.start()
        content = text[start_pos:end_pos]
        marker_pairs.append(
            {
                "index": i // 2,
                "marker_type": start_marker.group(1),
                "content": content,
                "start": start_marker.start(),
                "end": end_marker.end(),
            }
        )
    return marker_pairs


def replace_contents(text, replacements=None):
    if replacements is None:
        replacements = {}
    marker_pairs = find_marker_pairs(text)
    if not marker_pairs:
        return text

    new_text = text
    offset = 0
    for pair in marker_pairs:
        index = pair["index"]
        if index in replacements:
            new_content = replacements[index]
            marker_type = pair["marker_type"]
            replacement = f"{marker_type}\n{new_content}\n{marker_type}"
            original_length = pair["end"] - pair["start"]
            new_start_pos = pair["start"] + offset
            new_end_pos = pair["end"] + offset
            new_text = new_text[:new_start_pos] + replacement + new_text[new_end_pos:]
            offset += len(replacement) - original_length
    return new_text


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\service\agents\backend_client.py 的内容:
================================================================================
# %% backend_client.py
# -*- coding: utf-8 -*-
import json
import threading
import requests
from typing import Any, Dict, List, Optional, Tuple, Union

class BackendClient:
    def __init__(self, base_url: str = "http://127.0.0.1:8000", timeout: int = 300):
        self.base_url = base_url.rstrip("/")
        self.timeout = timeout
        self.openapi = None

    # ---------- 基础 ----------
    def ping(self) -> Tuple[bool, str]:
        """用 /openapi.json 判断后端是否在线，并缓存 schema。"""
        try:
            r = requests.get(f"{self.base_url}/openapi.json", timeout=10)
            if r.status_code == 200:
                self.openapi = r.json()
                return True, "Backend is up."
            return False, f"OpenAPI not available, status={r.status_code}"
        except Exception as e:
            return False, f"Ping failed: {e}"

    def list_paths(self) -> List[str]:
        if not self.openapi:
            ok, _ = self.ping()
            if not ok:
                return []
        return list(self.openapi.get("paths", {}).keys())

    # ---------- 查 /modeling 的请求体定义 ----------
    def _get_modeling_op(self) -> Optional[Dict[str, Any]]:
        """寻找 POST /modeling 的 OpenAPI 定义"""
        if not self.openapi:
            ok, _ = self.ping()
            if not ok:
                return None
        paths = self.openapi.get("paths", {})
        # 常见命名：/modeling
        for p, item in paths.items():
            post = item.get("post")
            if not post:
                continue
            # 兼容路径大小写或前缀
            if p.lower().endswith("/modeling") or p == "/modeling":
                return {"path": p, "op": post}
        # 没找到就返回 None
        return None

    def _infer_request_body(self) -> Dict[str, Any]:
        """
        返回请求体信息:
        {
          "path": "/modeling",
          "content_type": "application/json" 或 "multipart/form-data",
          "schema": {...},
          "field_map": {"files": ["字段A","字段B"], "json": {...}}  # 可选
        }
        """
        info = self._get_modeling_op()
        if not info:
            return {}

        post = info["op"]
        req_body = post.get("requestBody", {})
        content = req_body.get("content", {}) if isinstance(req_body, dict) else {}
        # 优先判断 multipart
        if "multipart/form-data" in content:
            return {
                "path": info["path"],
                "content_type": "multipart/form-data",
                "schema": content["multipart/form-data"].get("schema", {}),
            }
        # 其次 JSON
        if "application/json" in content:
            return {
                "path": info["path"],
                "content_type": "application/json",
                "schema": content["application/json"].get("schema", {}),
            }
        # 兜底
        return {
            "path": info["path"],
            "content_type": "application/json",
            "schema": {},
        }

    # ---------- 高层：提交一次建模任务 ----------
    def run_modeling(
        self,
        payload: Dict[str, Any],
        file_paths: Optional[Dict[str, Union[str, List[str]]]] = None,
        extra_headers: Optional[Dict[str, str]] = None,
    ) -> requests.Response:
        """
        payload: 结构化参数（会按 openapi 判断用 JSON 还是 form 字段）
        file_paths: 需要上传的文件，格式示例：
            {
              "files": ["abs.pdf", "data.csv"],  # 或单个字符串
              "extra_doc": "note.md"
            }
        extra_headers: 额外 header，比如鉴权
        """
        body_info = self._infer_request_body()
        if not body_info:
            raise RuntimeError("未在 OpenAPI 中找到 POST /modeling。")

        url = f"{self.base_url}{body_info['path']}"
        headers = extra_headers.copy() if extra_headers else {}

        if body_info["content_type"] == "multipart/form-data":
            data = {}
            files = []

            # 把 payload 当作普通字段放入 data
            # （若后端 schema 有更细字段名，你可以在这里按 schema 重命名）
            for k, v in payload.items():
                data[k] = json.dumps(v) if isinstance(v, (dict, list)) else str(v)

            # 处理文件
            if file_paths:
                for field, path_or_list in file_paths.items():
                    if isinstance(path_or_list, list):
                        for p in path_or_list:
                            files.append((field, (p.split("\\")[-1], open(p, "rb"))))
                    else:
                        p = path_or_list
                        files.append((field, (p.split("\\")[-1], open(p, "rb"))))

            return requests.post(url, data=data, files=files or None, headers=headers, timeout=self.timeout)

        else:
            # 默认 JSON
            headers["Content-Type"] = "application/json"
            body = payload
            # 如果含文件但接口是 JSON，通常要先把文件放到某个 “上传接口” 返回路径，再把路径放到 JSON；这里只演示直接 JSON。
            return requests.post(url, json=body, headers=headers, timeout=self.timeout)


# —— 一个方便放到 Tk 线程里的简易调用封装 ——
def run_in_thread(fn, on_done=None, on_error=None):
    def _wrap():
        try:
            res = fn()
            if on_done:
                on_done(res)
        except Exception as e:
            if on_error:
                on_error(e)
    t = threading.Thread(target=_wrap, daemon=True)
    t.start()
    return t


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\service\agents\mathmodelagent_client.py 的内容:
================================================================================
# %% mathmodelagent_client.py
# -*- coding: utf-8 -*-

"""
mathmodelagent_client.py — HTTP+WebSocket 双栈客户端（兼容旧用法）
================================================================

特性
----
- 依赖 `websocket-client`（而非已弃用/冷门的 `websocket` + gevent）。
- HTTP 使用 `requests`。
- “两项配置”模型：
  1) Base URL（HTTP），例如 http://host:port
  2) WS Base（可选），若不填则自动从 Base URL 推断（http→ws / https→wss）
- WebSocket：线程安全，内置自动重连（指数退避），支持 Ping 保活。
- 统一回调：on_open / on_message / on_error / on_close / on_reconnect。
- 同步/异步两种发送：
  - send_json / send_text：异步发送
  - request()：带 request_id 的同步请求，等待指定超时的对应响应。
- 支持 Token 认证（Authorization: Bearer <token>）、HTTP 代理、TLS 自定义。
- 兼容旧构造方式：若仅传入 `url="wss://host/ws"` 也能工作（等价于仅 WS 客户端）。

安装
----
    pip install websocket-client requests
"""

from __future__ import annotations

import json
import logging
import ssl
import threading
import time
import uuid
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, Optional, List
from urllib.parse import urlparse, urlunparse

import requests  # HTTP
import websocket  # 来自 websocket-client 包（包名即 websocket）


# ------------------------- 日志配置 -------------------------

logger = logging.getLogger(__name__)
if not logger.handlers:
    _h = logging.StreamHandler()
    _fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    _h.setFormatter(_fmt)
    logger.addHandler(_h)
logger.setLevel(logging.INFO)


# --------------------------- 内部结构 ---------------------------


@dataclass
class _PendingRequest:
    event: threading.Event = field(default_factory=threading.Event)
    response: Any | None = None
    error: Exception | None = None


def _infer_ws_base_from_http(base_url: str) -> str:
    """
    从 HTTP 基址推断 WS 基址：
    http://host:port -> ws://host:port
    https://host:port -> wss://host:port
    """
    u = urlparse(base_url)
    scheme = {"http": "ws", "https": "wss"}.get(u.scheme, "ws")
    return urlunparse((scheme, u.netloc, "", "", "", ""))


# --------------------------- 主客户端 ---------------------------


class MathModelAgentClient:
    def __init__(
        self,
        # 新用法（推荐）
        base_url: Optional[str] = None,  # HTTP 基址，如 http://host:port
        ws_base: Optional[str] = None,  # WS 基址，如 ws://host:port（可省略）
        # 旧用法（兼容）：直接传完整 WS URL
        url: Optional[str] = None,  # 完整 wss://host:port/ws
        # 通用参数
        token: Optional[str] = None,
        headers: Optional[Dict[str, str]] = None,
        proxy: Optional[str] = None,  # 形如 http://127.0.0.1:7890
        ping_interval: float = 20.0,
        ping_timeout: float = 10.0,
        reconnect: bool = True,
        max_reconnect_delay: float = 60.0,
        sslopt: Optional[Dict[str, Any]] = None,
        http_timeout: float = 30.0,
    ) -> None:
        """
        说明：
        - 推荐：传 base_url（HTTP），可选 ws_base；WS 可用 connect_ws() 建立。
        - 兼容：若只传 url（完整 WS），则作为仅 WS 客户端工作（connect() 生效）。
        """
        # HTTP
        self.base_url = (base_url or "").rstrip("/")
        self.ws_base = (ws_base or (_infer_ws_base_from_http(self.base_url) if self.base_url else "")).rstrip("/")

        # 旧用法：直接给完整 WS URL
        self._legacy_ws_url = url  # 若提供，则 connect() 走它

        self.token = token
        self.base_headers = headers or {}
        self.proxy = proxy
        self.ping_interval = ping_interval
        self.ping_timeout = ping_timeout
        self.reconnect = reconnect
        self.max_reconnect_delay = max_reconnect_delay
        self.sslopt = sslopt or {"cert_reqs": ssl.CERT_REQUIRED}
        self.http_timeout = http_timeout

        # WS 状态
        self._wsapp: Optional[websocket.WebSocketApp] = None
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
        self._connected = threading.Event()

        # 同步请求映射表
        self._pending: Dict[str, _PendingRequest] = {}
        self._pending_lock = threading.Lock()

        # 回调
        self._on_open_cb: Optional[Callable[[], None]] = None
        self._on_message_cb: Optional[Callable[[Any], None]] = None
        self._on_error_cb: Optional[Callable[[Exception], None]] = None
        self._on_close_cb: Optional[Callable[[int, str], None]] = None
        self._on_reconnect_cb: Optional[Callable[[int, float], None]] = None

    # ---------------------- 装饰器：绑定回调 ----------------------
    def on_open(self, func: Callable[[], None]):
        self._on_open_cb = func
        return func

    def on_message(self, func: Callable[[Any], None]):
        self._on_message_cb = func
        return func

    def on_error(self, func: Callable[[Exception], None]):
        self._on_error_cb = func
        return func

    def on_close(self, func: Callable[[int, str], None]):
        self._on_close_cb = func
        return func

    def on_reconnect(self, func: Callable[[int, float], None]):
        """当触发自动重连时调用；参数为 (attempt, delay_seconds)。"""
        self._on_reconnect_cb = func
        return func

    # ======================= HTTP 能力 =======================
    def _http_headers(self) -> Dict[str, str]:
        h = dict(self.base_headers)
        if self.token:
            h.setdefault("Authorization", f"Bearer {self.token}")
        h.setdefault("Content-Type", "application/json")
        return h

    def post(self, path: str, json_obj: Dict[str, Any]) -> Dict[str, Any]:
        """
        通用 POST。path 必须以 "/" 开头。
        例：post("/api/modeling/submit", {...})
        """
        if not self.base_url:
            raise RuntimeError("base_url is not set")
        url = f"{self.base_url}{path}"
        proxies = {"http": self.proxy, "https": self.proxy} if self.proxy else None
        resp = requests.post(
            url,
            headers=self._http_headers(),
            json=json_obj,
            timeout=self.http_timeout,
            proxies=proxies,
        )
        resp.raise_for_status()
        try:
            return resp.json()
        except Exception:
            return {"ok": True, "text": resp.text}

    def submit_modeling(self, payload: Dict[str, Any], path: str = "/api/modeling/submit") -> Dict[str, Any]:
        """
        提交建模任务（薄封装）。默认路由为占位名，请按后端实际路径替换。
        """
        return self.post(path, payload)

    # ======================= WebSocket 能力 =======================
    def connect_ws(self, path: str = "/ws", block: bool = False) -> None:
        """
        使用 ws_base + path 建立 WS 连接。
        - ws_base 为空时，会尝试从 base_url 推断（http→ws / https→wss）。
        """
        if not self.ws_base and not self._legacy_ws_url:
            raise RuntimeError("ws_base/url is not set (provide base_url or url)")
        ws_url = self._legacy_ws_url or f"{self.ws_base}{path}"
        self._start_ws_thread(ws_url)
        if block and self._thread is not None:
            self._thread.join()

    def connect(self, block: bool = False) -> None:
        """
        兼容旧版 API：当 __init__ 提供了 url（完整 WS 地址）时可用。
        """
        if not self._legacy_ws_url:
            raise RuntimeError("legacy url not provided; use connect_ws(base_url/ws_base) instead")
        self._start_ws_thread(self._legacy_ws_url)
        if block and self._thread is not None:
            self._thread.join()

    def close(self) -> None:
        """优雅关闭连接与线程（仅 WS 部分需要关闭；HTTP 无需关闭）"""
        self._stop_event.set()
        if self._wsapp is not None:
            try:
                self._wsapp.close()
            except Exception as e:  # noqa
                logger.debug("close error: %s", e)
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=3)
        self._connected.clear()

    def is_connected(self) -> bool:
        return self._connected.is_set()

    # ---------------------- 发送 API（WS） ----------------------
    def send_text(self, text: str) -> None:
        if not self._wsapp:
            raise RuntimeError("WebSocket is not connected")
        self._wsapp.send(text)

    def send_json(self, obj: Dict[str, Any]) -> None:
        self.send_text(json.dumps(obj, ensure_ascii=False))

    def request(self, obj: Dict[str, Any], timeout: float = 10.0) -> Any:
        """
        同步请求-响应：附加 request_id 并阻塞等待对应响应或超时。
        要求后端在响应中原样返回 `request_id` 字段。
        """
        req_id = obj.get("request_id") or str(uuid.uuid4())
        obj["request_id"] = req_id

        pend = _PendingRequest()
        with self._pending_lock:
            self._pending[req_id] = pend

        try:
            self.send_json(obj)
        except Exception as e:  # 发送失败
            with self._pending_lock:
                self._pending.pop(req_id, None)
            raise e

        ok = pend.event.wait(timeout=timeout)
        with self._pending_lock:
            self._pending.pop(req_id, None)
        if not ok:
            raise TimeoutError(f"request timeout: {req_id}")
        if pend.error:
            raise pend.error
        return pend.response

    # ---------------------- 内部：WS 循环 ----------------------
    def _http_like_headers(self) -> List[str]:
        """将 HTTP 头转为 websocket-client 需要的 header 列表形式。"""
        headers: List[str] = []
        merged = self._http_headers()
        for k, v in merged.items():
            headers.append(f"{k}: {v}")
        return headers

    def _start_ws_thread(self, ws_url: str) -> None:
        self._stop_event.clear()
        if self._thread and self._thread.is_alive():
            return
        t = threading.Thread(target=self._run_forever, args=(ws_url,), name="MathModelAgentWS", daemon=True)
        t.start()
        self._thread = t

    def _run_forever(self, ws_url: str) -> None:
        attempt = 0
        backoff = 1.0
        while not self._stop_event.is_set():
            try:
                self._wsapp = websocket.WebSocketApp(
                    ws_url,
                    header=self._http_like_headers(),
                    on_open=self._on_open,
                    on_message=self._on_message,
                    on_error=self._on_error,
                    on_close=self._on_close,
                    on_pong=self._on_pong,
                )

                # 代理拆分给 websocket-client
                http_proxy_host = http_proxy_port = None
                if self.proxy:
                    try:
                        scheme, rest = self.proxy.split("://", 1)
                        host_port = rest.split("/", 1)[0]
                        host, port = host_port.split(":", 1)
                        http_proxy_host = host
                        http_proxy_port = int(port)
                    except Exception:
                        logger.warning("proxy format invalid, expecting http://host:port")

                self._connected.clear()
                self._wsapp.run_forever(
                    sslopt=self.sslopt,
                    http_proxy_host=http_proxy_host,
                    http_proxy_port=http_proxy_port,
                    ping_interval=self.ping_interval if self.ping_interval > 0 else None,
                    ping_timeout=self.ping_timeout if self.ping_interval > 0 else None,
                )
            except Exception as e:
                logger.error("WebSocket error: %s", e)
                self._connected.clear()

            if not self.reconnect or self._stop_event.is_set():
                break

            # 自动重连
            attempt += 1
            delay = min(backoff, self.max_reconnect_delay)
            if self._on_reconnect_cb:
                try:
                    self._on_reconnect_cb(attempt, delay)
                except Exception:
                    pass
            logger.info("reconnecting in %.1fs (attempt %d)", delay, attempt)
            self._sleep(delay)
            backoff = min(backoff * 2, self.max_reconnect_delay)

    # ---------------------- WS 回调 ----------------------
    def _on_open(self, ws: websocket.WebSocketApp):  # noqa: ARG002
        self._connected.set()
        logger.info("WebSocket connected")
        if self._on_open_cb:
            try:
                self._on_open_cb()
            except Exception as e:
                logger.debug("on_open callback error: %s", e)

    def _on_message(self, ws: websocket.WebSocketApp, message: str | bytes):  # noqa: ARG002
        try:
            parsed = self.parse_message(message)
            self._route_response(parsed)
            if self._on_message_cb:
                self._on_message_cb(parsed)
        except Exception as e:
            logger.error("on_message error: %s", e)

    def _on_error(self, ws: websocket.WebSocketApp, error: Exception):  # noqa: ARG002
        logger.error("WebSocket error: %s", error)
        if self._on_error_cb:
            try:
                self._on_error_cb(error)
            except Exception:
                pass

    def _on_close(self, ws: websocket.WebSocketApp, status_code: int, msg: str):  # noqa: ARG002
        self._connected.clear()
        logger.info("WebSocket closed (%s): %s", status_code, msg)
        if self._on_close_cb:
            try:
                self._on_close_cb(status_code, msg)
            except Exception:
                pass

    def _on_pong(self, ws: websocket.WebSocketApp, data: str | bytes):  # noqa: ARG002
        logger.debug("< PONG %s", data)

    # ---------------------- 解析与路由 ----------------------
    def parse_message(self, message: str | bytes) -> Any:
        """优先按 JSON 解析；不是 JSON 则返回原始文本/二进制。"""
        if isinstance(message, (bytes, bytearray)):
            try:
                return json.loads(message.decode("utf-8"))
            except Exception:
                return message
        try:
            return json.loads(message)
        except Exception:
            return message

    def _route_response(self, payload: Any) -> None:
        """若是带 request_id 的响应，唤醒对应等待的 request()；否则由 on_message 处理。"""
        if not isinstance(payload, dict):
            return
        req_id = payload.get("request_id")
        if not req_id:
            return
        with self._pending_lock:
            pend = self._pending.get(req_id)
        if pend is None:
            return
        if payload.get("ok") is False and "error" in payload:
            pend.error = RuntimeError(str(payload["error"]))
        else:
            pend.response = payload
        pend.event.set()

    # ---------------------- 工具 ----------------------
    @staticmethod
    def _sleep(seconds: float) -> None:
        try:
            time.sleep(seconds)
        except KeyboardInterrupt:
            pass


# ----------------------------- 简单 CLI -----------------------------

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="MathModelAgent HTTP+WS Client")
    # 新用法
    parser.add_argument("--base", dest="base_url", default=None, help="HTTP base, e.g. http://127.0.0.1:8000")
    parser.add_argument("--ws", dest="ws_base", default=None, help="WS base, e.g. ws://127.0.0.1:8000 (optional)")
    parser.add_argument("--ws-path", dest="ws_path", default="/ws", help="WS path, default: /ws")
    # 旧用法
    parser.add_argument("--url", dest="legacy_url", default=None, help="full WS url, e.g. wss://host/ws")
    # 通用
    parser.add_argument("--token", default=None, help="Bearer token")
    parser.add_argument("--proxy", default=None, help="http://host:port")
    parser.add_argument("--ping", type=float, default=20.0, help="WS ping interval seconds (<=0 to disable)")
    args = parser.parse_args()

    client = MathModelAgentClient(
        base_url=args.base_url,
        ws_base=args.ws_base,
        url=args.legacy_url,
        token=args.token,
        proxy=args.proxy,
        ping_interval=args.ping,
        sslopt={"cert_reqs": ssl.CERT_NONE},  # 内网自签名时可用；注意安全风险
    )

    @client.on_open
    def _opened():
        logger.info("opened -> send hello")
        try:
            client.send_json({"type": "hello", "ts": time.time()})
        except Exception as e:
            logger.error("send hello failed: %s", e)

    @client.on_message
    def _msg(m):
        logger.info("< %s", m)

    @client.on_reconnect
    def _reconn(attempt, delay):
        logger.info("reconnect attempt=%d delay=%.1fs", attempt, delay)

    # 选择连接方式
    if args.legacy_url:
        client.connect(block=True)
    else:
        client.connect_ws(path=args.ws_path, block=True)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\utils\aid_loader.py 的内容:
================================================================================
# %% utils/aid_loader.py
# -*- coding: utf-8 -*-

from pathlib import Path
from .paths import resource_path

# 允许的后缀（按你的需要增减）
_ALLOWED_SUFFIX = {".txt", ".md", ".tex"}  # 需要就加，或只留 .txt


def list_aid_files():
    """
    返回 [(显示名, 绝对路径), ...]，递归 utils/ai-aid-mcmaa
    显示名用相对目录，适合放到下拉框
    """
    base = Path(resource_path("utils", "ai-aid-mcmaa"))

    if not base.exists():
        return []

    files = []
    for p in base.rglob("*"):
        if p.is_file() and p.suffix.lower() in _ALLOWED_SUFFIX:
            rel = p.relative_to(base).as_posix()
            files.append((rel, str(p)))

    # 按相对路径排序：带数字前缀的会自然排序
    files.sort(key=lambda t: t[0].lower())
    return files


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\utils\clear_pycache.py 的内容:
================================================================================
# %% utils/clear_pycache.py
# -*- coding: utf-8 -*-

import os
import shutil


def clear_pycache(root_dir="."):
    for dirpath, dirnames, _ in os.walk(root_dir):
        for dirname in dirnames:
            # 如果是 __pycache__ 文件夹，删除它
            if dirname == "__pycache__":
                dir_to_delete = os.path.join(dirpath, dirname)
                # print(f"Deleting: {dir_to_delete}")
                shutil.rmtree(dir_to_delete)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\utils\paths.py 的内容:
================================================================================
# utils/paths.py
# -*- coding: utf-8 -*-
import sys
from pathlib import Path


def resource_path(*parts: str) -> str:
    """
    - 打包后：以 _MEIPASS 为根
    - 开发期：以项目根目录为根（utils 的上一级）
    - 可传多段路径：resource_path("utils", "ai-aid-mcmaa", "1.txt")
    """
    if hasattr(sys, "_MEIPASS"):
        base = Path(sys._MEIPASS)  # type: ignore[attr-defined]
    else:
        base = Path(__file__).resolve().parents[1]
    return str(base.joinpath(*parts))


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\common_widgets.py 的内容:
================================================================================
# %% view/common_widgets.py
# -*- coding: utf-8 -*-

# 内置库
from tkinter import *
import tkinter.filedialog as filedialog
from tkinter.scrolledtext import ScrolledText
import tkinter.messagebox as messagebox

# 第三方库
import ttkbootstrap as ttk


class TextWidget(ttk.Frame):
    def __init__(self, master, on_info=None, **kwargs):
        """
        文本小组件：
        - 带滚动条的可编辑文本框
        - 常用快捷键：撤销/全选/另存为（支持 Win/Linux 的 Ctrl 与 macOS 的 Command）
        :param master: 父容器
        :param on_info: 可选的回调函数，形如 on_info(msg: str)，用于显示提示信息
        :param kwargs: 传给 ttk.Frame 的其他参数
        """
        super().__init__(master, **kwargs)
        self.on_info = on_info

        # 创建可滚动的文本框，启用撤销功能
        self.textbox = ScrolledText(self, undo=True)
        self.textbox.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 设置文本框为可编辑状态
        self.textbox.config(state="normal")

        # 绑定快捷键（Win/Linux: Ctrl，macOS: Command）
        self.textbox.bind("<Control-z>", lambda event: self.textbox.edit_undo())  # Ctrl+Z 撤销
        self.textbox.bind("<Command-z>", lambda event: self.textbox.edit_undo())  # ⌘Z 撤销
        self.textbox.bind("<Control-Shift-s>", lambda event: self.save_as())  # Ctrl+Shift+S 另存为
        self.textbox.bind("<Command-Shift-s>", lambda event: self.save_as())  # ⌘⇧S 另存为
        self.textbox.bind("<Control-a>", self.select_all)  # Ctrl+A 全选
        self.textbox.bind("<Command-a>", self.select_all)  # ⌘A 全选

    def append(self, s):
        """清空并写入内容"""
        self.textbox.delete(1.0, "end")
        self.textbox.insert("end", s)

    def clear(self):
        """清空内容"""
        self.textbox.delete(1.0, "end")

    def get_content(self):
        """获取内容（去除末尾换行）"""
        return self.textbox.get(1.0, "end-1c")

    def save_as(self):
        """另存为功能"""
        file_path = filedialog.asksaveasfilename(
            defaultextension=".md",
            filetypes=[("Markdown files", "*.md"), ("All files", "*.*")],
            title="另存为",
        )
        if not file_path:
            return

        # 保存文本框内容到文件
        content = self.get_content()
        try:
            with open(file_path, "w", encoding="utf-8") as file:
                file.write(content)
        except Exception as e:
            messagebox.showerror("保存失败", f"写入文件时出错：\n{e}")
            return

        # 提示成功：优先用回调，其次用消息框
        msg = f"成功：内容已另存为\n{file_path}"
        if callable(self.on_info):
            try:
                self.on_info(msg)
            except Exception:
                # 回调异常时回退到消息框
                messagebox.showinfo("成功", msg)
        else:
            messagebox.showinfo("成功", msg)

    def select_all(self, event=None):
        """全选文本"""
        self.textbox.tag_add("sel", "1.0", "end")
        return "break"  # 阻止默认事件处理


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\config.py 的内容:
================================================================================
# %% view/config.py
# -*- coding: utf-8 -*-

# 内置库
import os


# 全局配置
DATA_CONFIG = {
    "app": None,
    "window": None,
    "screen": None,
    "py_path": os.path.dirname(os.path.abspath(__file__)),
}

SCREEN_CONFIG = {"borderwidth": 5, "relief": "raised"}
MAIN_FRAME_CONFIG = {"borderwidth": 5, "relief": "sunken"}
RAISED_SUBFRAME_CONFIG = {"borderwidth": 2, "relief": "raised"}
FLAT_SUBFRAME_CONFIG = {"borderwidth": 2}
ENTRY_LABEL_CONFIG = {"padding": 2}


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\__init__.py 的内容:
================================================================================


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\screens\screen_workbench.py 的内容:
================================================================================
# %% view/screens/screen_workbench.py
# -*- coding: utf-8 -*-

"""
Screen_Workbench — 一体化工作台（View）
=====================================
职责（MVC：View）
- 只负责 UI 构建、事件绑定、以及把用户操作转交给 Controller；
- 文本解析/文件 I/O/业务逻辑统一委托给 WorkbenchController；
- 代码按“Tab 功能”进行分组：编辑/预览、替换、辅助、Agent、导航树。

快捷键
- Ctrl+O 打开；Ctrl+S 保存（在“替换”页时为“应用替换”，在“辅助”页为“插入到编辑器”）；
- Ctrl+F 查找；Ctrl+H 替换。
"""
from __future__ import annotations

import re
import time
from tkinter import *
from tkinter.scrolledtext import ScrolledText
import tkinter.filedialog as filedialog
import tkinter.messagebox as messagebox
import ttkbootstrap as ttk
from tkinterdnd2 import DND_FILES

from ..config import SCREEN_CONFIG, MAIN_FRAME_CONFIG
from controller.workbench_controller import WorkbenchController


class Screen_Workbench(ttk.Frame):
    """统一工作台视图。

    左：导航（大纲/问题/代码）
    右：Notebook（编辑/预览｜替换｜辅助｜Agent）
    """

    MODE_NAME = "一体化工作台"

    # ---------------------------------------------------------------------
    # 生命周期
    # ---------------------------------------------------------------------
    def __init__(self, master):
        super().__init__(master, **SCREEN_CONFIG)
        self.place(relx=0, rely=0, relwidth=1, relheight=1)

        # Controller & 轻量状态
        self.ctrl = WorkbenchController()
        self.selected_pair_display = StringVar(value="")  # 替换页下拉

        # 主布局：左右分割
        self._build_layout()
        self._build_left_nav()
        self._build_right_tabs()

        # 绑定“切页时刷新”的钩子
        self.notebook.bind("<<NotebookTabChanged>>", self._on_tab_changed)

        # Agent 回调 -> 回 UI 线程
        self.ctrl.set_agent_handlers(
            on_status=lambda s: self.after(0, lambda: self._agent_set_status(s)),
            on_message=lambda m: self.after(0, lambda: self._agent_log(f"< {m}\n")),
            on_error=lambda e: self.after(0, lambda: messagebox.showerror("Agent 错误", e)),
        )

        # 初次刷新
        self._refresh_aid_files()

        # 全局 Ctrl/⌘+S：替换页=应用替换；辅助页=插入；其它页=保存
        self.bind_all("<Control-s>", self._on_global_save_or_apply)
        self.bind_all("<Command-s>", self._on_global_save_or_apply)

    # ---------------------------------------------------------------------
    # 对外给菜单用的 API（主窗口菜单调用）
    # ---------------------------------------------------------------------
    def get_recent_files(self):
        """返回最近文件列表（最新在前）。"""
        return list(self.ctrl.recent_files)

    def quick_open(self, path: str):
        """Quick Open 菜单项点击：委托 Controller，View 负责 UI 更新与文案。"""
        ok, _msg, text = self.ctrl.quick_open(path)
        if not ok:
            messagebox.showwarning("提示", "文件不存在，已从最近列表移除。")
            return
        self._editor_set_text(text)
        self.set_preview(f"文件已加载: {path}")
        self._refresh_marker_pairs()
        self._rebuild_all_trees()
        self.notebook.select(self.tab_edit)

    # ---------------------------------------------------------------------
    # 布局与 UI 构建
    # ---------------------------------------------------------------------

    def _build_layout(self):
        self.main_paned = ttk.PanedWindow(self, orient="horizontal")
        self.main_paned.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 左侧：导航容器
        self.left_frame = ttk.Frame(self.main_paned, **MAIN_FRAME_CONFIG)
        self.main_paned.add(self.left_frame, weight=30)

        # 右侧：Notebook 容器
        self.right_frame = ttk.Frame(self.main_paned, **MAIN_FRAME_CONFIG)
        self.main_paned.add(self.right_frame, weight=70)

        # 初始化时给个合理的分割（sash 索引从 0 开始，避免无效索引）
        try:
            self.main_paned.sashpos(1, 260)
        except Exception:
            pass

    def _build_left_nav(self):
        self.left_tabs = ttk.Notebook(self.left_frame)
        self.left_tabs.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 大纲
        self.outline_tab = ttk.Frame(self.left_tabs)
        self.left_tabs.add(self.outline_tab, text="大纲")
        self.outline_tree = ttk.Treeview(self.outline_tab, show="tree")
        self.outline_tree.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.outline_tree.bind("<<TreeviewSelect>>", self.on_outline_select)
        self.outline_tree.bind("<Double-1>", self._goto_outline_line)

        # 问题（含右键菜单）
        self.problem_tab = ttk.Frame(self.left_tabs)
        self.left_tabs.add(self.problem_tab, text="问题")
        self.problem_tree = ttk.Treeview(self.problem_tab, show="tree")
        self.problem_tree.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.problem_tree.bind("<<TreeviewSelect>>", self.on_problem_select)
        self._init_problem_context_menu()

        # 代码（专门放 codeblock）
        self.code_tab = ttk.Frame(self.left_tabs)
        self.left_tabs.add(self.code_tab, text="代码")
        self.code_tree = ttk.Treeview(self.code_tab, show="tree")
        self.code_tree.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.code_tree.bind("<<TreeviewSelect>>", self.on_code_select)

    def _build_right_tabs(self):
        self.notebook = ttk.Notebook(self.right_frame)
        self.notebook.place(relx=0, rely=0, relwidth=1, relheight=1)

        self._build_tab_edit_preview()
        self._build_tab_replace()
        self._build_tab_aid()
        self._build_tab_agent()

    # --------------------------- Edit / Preview ---------------------------
    def _build_tab_edit_preview(self):
        # 编辑
        self.tab_edit = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_edit, text="编辑")
        self.editor = ScrolledText(self.tab_edit, wrap="none", undo=True)
        self.editor.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 快捷键（Win/Linux: Ctrl，macOS: Command）
        self.editor.bind("<Control-a>", lambda e: self._select_all(self.editor))
        self.editor.bind("<Control-s>", lambda e: (self.save_current_text(), "break"))
        self.editor.bind("<Control-o>", lambda e: (self.select_file(), "break"))
        self.editor.bind("<Control-f>", lambda e: (self._open_find_dialog(), "break"))
        self.editor.bind("<Control-h>", lambda e: (self._open_replace_dialog(), "break"))
        self.editor.bind("<Command-a>", lambda e: self._select_all(self.editor))
        self.editor.bind("<Command-s>", lambda e: (self.save_current_text(), "break"))
        self.editor.bind("<Command-o>", lambda e: (self.select_file(), "break"))
        self.editor.bind("<Command-f>", lambda e: (self._open_find_dialog(), "break"))
        self.editor.bind("<Command-h>", lambda e: (self._open_replace_dialog(), "break"))

        # 预览
        self.tab_preview = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_preview, text="预览")
        self.preview = ScrolledText(self.tab_preview, wrap="word", state="disabled")
        self.preview.place(relx=0, rely=0, relwidth=1, relheight=1)

    # ------------------------------- 替换页 -------------------------------

    def _build_tab_replace(self):
        self.tab_replace = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_replace, text="替换")

        topbar = ttk.Frame(self.tab_replace, padding=(8, 6))
        topbar.pack(side="top", fill="x")

        ttk.Label(topbar, text="标记对：").pack(side="left")
        self.pair_combo = ttk.Combobox(
            topbar,
            textvariable=self.selected_pair_display,
            state="readonly",
            width=40,
        )
        self.pair_combo.pack(side="left", padx=(6, 8), fill="x", expand=True)
        self.pair_combo.bind("<<ComboboxSelected>>", lambda e: self.on_pair_select())

        # 保留“仅应用所选” + “应用所有块”
        ttk.Button(
            topbar,
            text="应用所有块（Ctrl+S）",
            bootstyle="primary",
            command=self.apply_replace_all,
        ).pack(side="right")
        ttk.Button(
            topbar,
            text="仅应用所选",
            command=self.apply_replace,
        ).pack(side="right", padx=(0, 8))

        # 右侧分屏区域
        self.replace_paned = ttk.PanedWindow(self.tab_replace, orient="horizontal")
        self.replace_paned.pack(side="top", fill="both", expand=True)

        # 保存“分屏块”的引用：(label, text_widget)
        self.replace_blocks = []

        # 初始给一个空块
        self._rebuild_replace_blocks([])

        # NEW: 让整个“替换”页支持文件拖放
        try:
            self.tab_replace.drop_target_register(DND_FILES)
            self.tab_replace.dnd_bind("<<Drop>>", self._on_drop_files_to_replace_page)
        except Exception:
            pass


    # -------------------------------- 辅助页 --------------------------------
    def _build_tab_aid(self):
        self.tab_aid = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_aid, text="辅助")

        aid_top = ttk.Frame(self.tab_aid, padding=(8, 6))
        aid_top.pack(side="top", fill="x")

        ttk.Label(aid_top, text="辅助文件：").pack(side="left")
        self.aid_selected = ttk.StringVar(value="")
        self.aid_combo = ttk.Combobox(aid_top, textvariable=self.aid_selected, state="readonly", width=46)
        self.aid_combo.pack(side="left", padx=(6, 8), fill="x", expand=True)
        self.aid_combo.bind("<<ComboboxSelected>>", lambda e: self._on_aid_select())

        ttk.Button(
            aid_top, text="插入到编辑器（Ctrl+S）", bootstyle="secondary", command=self.apply_aid_to_editor
        ).pack(side="right")

        self.aid_view = ScrolledText(self.tab_aid, wrap="word")
        self.aid_view.pack(side="top", fill="both", expand=True)
        self.aid_view.bind("<Control-a>", self._select_all)
        self.aid_view.bind("<Command-a>", self._select_all)

    # -------------------------------- Agent 页 --------------------------------
    def _build_tab_agent(self):
        self.tab_agent = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_agent, text="Agent")

        # 顶部连接区
        agent_top = ttk.Frame(self.tab_agent, padding=(8, 6))
        agent_top.pack(side="top", fill="x")

        ttk.Label(agent_top, text="URL:").pack(side="left")
        self.agent_url = ttk.StringVar(value="ws://127.0.0.1:8000/ws")
        ttk.Entry(agent_top, textvariable=self.agent_url, width=34).pack(side="left", padx=(4, 12))

        ttk.Label(agent_top, text="Token:").pack(side="left")
        self.agent_token = ttk.StringVar(value="")
        ttk.Entry(agent_top, textvariable=self.agent_token, width=22, show="•").pack(side="left", padx=(4, 12))

        ttk.Label(agent_top, text="Proxy:").pack(side="left")
        self.agent_proxy = ttk.StringVar(value="")
        ttk.Entry(agent_top, textvariable=self.agent_proxy, width=18).pack(side="left", padx=(4, 12))

        ttk.Button(agent_top, text="连接", bootstyle="success", command=self._agent_connect).pack(side="left", padx=4)
        ttk.Button(agent_top, text="断开", command=self._agent_close).pack(side="left", padx=4)

        # 中部消息/输入区
        mid = ttk.Frame(self.tab_agent, padding=(8, 6))
        mid.pack(side="top", fill="both", expand=True)

        # 左：消息控制
        left = ttk.Frame(mid)
        left.pack(side="left", fill="y")
        ttk.Button(left, text="Ping", command=self._agent_ping).pack(side="top", fill="x", pady=(0, 6))
        ttk.Button(left, text="发送请求 infer", bootstyle="primary", command=self._agent_infer).pack(
            side="top", fill="x"
        )

        # 右：日志/状态
        right = ttk.Frame(mid)
        right.pack(side="left", fill="both", expand=True, padx=(12, 0))
        ttk.Label(right, text="状态:").pack(anchor="w")
        self.agent_status_var = ttk.StringVar(value="disconnected")
        ttk.Label(right, textvariable=self.agent_status_var, bootstyle="secondary").pack(anchor="w", pady=(0, 6))
        ttk.Label(right, text="消息:").pack(anchor="w")
        self.agent_console = ScrolledText(right, wrap="word", state="disabled", height=14)
        self.agent_console.pack(fill="both", expand=True)

    # ---------------------------------------------------------------------
    # Tab 变更钩子
    # ---------------------------------------------------------------------
    def _on_tab_changed(self, _evt=None):
        try:
            tab_text = self.notebook.tab(self.notebook.select(), "text")
        except Exception:
            return
        if tab_text == "替换":
            self._refresh_marker_pairs()
        elif tab_text == "辅助":
            self._refresh_aid_files()

    # ---------------------------------------------------------------------
    # 文件 I/O（菜单/快捷键驱动）
    # ---------------------------------------------------------------------
    def select_file(self):
        file_path = filedialog.askopenfilename(
            title="选择 LaTeX 文件",
            filetypes=[("LaTeX files", "*.tex"), ("LaTeX Template files", "*.template"), ("All files", "*.*")],
        )
        if file_path:
            self._open_path(file_path)

    def _open_path(self, file_path: str):
        try:
            data = self.ctrl.open_path(file_path)
            self._editor_set_text(data.get("text", ""))
            self.set_preview(f"文件已加载: {file_path}")
            self._refresh_marker_pairs()
            self._rebuild_all_trees()
            self.notebook.select(self.tab_edit)
        except Exception as e:
            self.set_preview(f"错误: {e}")

    def reload_from_disk(self):
        """从磁盘重载（不改动文件内容）。"""
        data = self.ctrl.reload_from_disk()
        text = data.get("text", "")
        if not text:
            return
        self._editor_set_text(text)
        self._refresh_marker_pairs()
        self._rebuild_all_trees()
        self.set_preview("已从磁盘重载。")

    def save_current_text(self):
        ok, msg = self.ctrl.save_text(self._get_editor_text())
        if not ok:
            self.set_preview(f"保存失败：{msg or '未知错误'}")
            return
        self._rebuild_all_trees()
        self.set_preview("保存成功。")

    # ---------------------------------------------------------------------
    # 导航树：构建与事件
    # ---------------------------------------------------------------------
    def _rebuild_all_trees(self):
        self._build_outline_tree()
        self._build_problem_tree()
        self._build_code_tree()

    def _build_outline_tree(self):
        self.outline_tree.delete(*self.outline_tree.get_children())
        if not self.ctrl.extractor:
            return
        nodes = self.ctrl.make_outline_nodes(self.ctrl.extractor)
        stack = [("", 0)]  # [(tk_node_id, level)]
        for n in nodes:
            title, level, line_num = n["title"], n["level"], n["line_num"]
            while stack and level <= stack[-1][1]:
                stack.pop()
            parent = stack[-1][0] if stack else ""
            node_id = self.outline_tree.insert(parent, "end", text=title, values=(line_num, level))
            stack.append((node_id, level))

    def _build_problem_tree(self):
        self.problem_tree.delete(*self.problem_tree.get_children())
        if not self.ctrl.extractor:
            return
        items = self.ctrl.make_problem_tree(self.ctrl.extractor)
        for item in items:
            pnode = self.problem_tree.insert("", "end", text=item["text"], values=item["values"])
            for child in item.get("children", []):
                self.problem_tree.insert(pnode, "end", text=child["text"], values=child["values"])

    def _build_code_tree(self):
        self.code_tree.delete(*self.code_tree.get_children())
        if not self.ctrl.extractor:
            return
        nodes = self.ctrl.make_code_nodes(self.ctrl.extractor)
        for n in nodes:
            self.code_tree.insert("", "end", text=n["text"], values=n["values"])

    # ---- 导航事件 ----
    def on_outline_select(self, _event):
        if not self.ctrl.extractor:
            return
        item = self.outline_tree.focus()
        vals = self.outline_tree.item(item, "values")
        if not vals:
            return
        line_num, section_level = map(int, vals)
        text = self.ctrl.render_outline_preview(self.ctrl.extractor, line_num, section_level)
        self.set_preview(text)

    def _goto_outline_line(self, _event=None):
        """双击大纲项：编辑器跳转到对应行，并临时高亮。"""
        item = self.outline_tree.focus()
        vals = self.outline_tree.item(item, "values")
        if not vals:
            return
        line_num = int(vals[0]) + 1  # Tk 文本行号从 1 开始
        self.notebook.select(self.tab_edit)
        idx = f"{line_num}.0"
        self.editor.see(idx)
        self.editor.mark_set("insert", idx)
        self.editor.tag_configure("goto_flash", background="#a5d6a7")
        self.editor.tag_add("goto_flash", idx, f"{line_num}.end")
        self.editor.after(2000, lambda: self.editor.tag_delete("goto_flash"))

    def on_problem_select(self, _event):
        if not self.ctrl.extractor:
            return
        item = self.problem_tree.focus()
        vals = self.problem_tree.item(item, "values")
        if not vals:
            return
        if len(vals) == 1:  # 点击“问题X” -> 合并预览（View 侧加分隔标题，仅展示）
            k = vals[0]
            text = self._compose_problem_preview_with_headings(k)
        else:
            k, part = vals
            body = self.ctrl.build_problem_part_text(self.ctrl.extractor, k, part)
            title_map = {
                "abstract": "摘要片段",
                "restate": "问题重述",
                "analysis": "问题分析",
                "modeling": "模型与求解",
            }
            header = f"% ===== {title_map.get(part, part)} =====\n" if body else ""
            text = f"{header}{body}".strip()
        self.set_preview(text)

    def _compose_problem_preview_with_headings(self, k: str) -> str:
        """合并预览（View 侧添加分节标题，避免污染业务层）。"""
        pieces = [
            ("摘要片段", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "abstract")),
            ("问题重述", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "restate")),
            ("问题分析", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "analysis")),
            ("模型与求解", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "modeling")),
        ]
        out = []
        for title, body in pieces:
            if body:
                out.append(f"% ===== {title} =====")
                out.append(body)
                out.append("")
        return "\n".join(out).strip()

    def on_code_select(self, _event):
        if not self.ctrl.extractor:
            return
        item = self.code_tree.focus()
        vals = self.code_tree.item(item, "values")
        if not vals:
            return
        line_num, level = map(int, vals)
        text = self.ctrl.render_code_preview(self.ctrl.extractor, line_num, level)
        self.set_preview(text)

    # ---- 问题树：右键菜单 ----
    def _init_problem_context_menu(self):
        self.problem_menu = ttk.Menu(self.problem_tree, tearoff=False)
        self.problem_menu.add_command(label="复制该问题：摘要+重述+分析+建模", command=self._copy_problem_merged)
        self.problem_menu.add_separator()
        self.problem_menu.add_command(label="只复制 摘要片段", command=lambda: self._copy_problem_part("abstract"))
        self.problem_menu.add_command(label="只复制 问题重述", command=lambda: self._copy_problem_part("restate"))
        self.problem_menu.add_command(label="只复制 问题分析", command=lambda: self._copy_problem_part("analysis"))
        self.problem_menu.add_command(label="只复制 模型与求解", command=lambda: self._copy_problem_part("modeling"))
        self.problem_tree.bind("<Button-3>", self._popup_problem_menu)

    def _popup_problem_menu(self, event):
        try:
            iid = self.problem_tree.identify_row(event.y)
            if iid:
                self.problem_tree.selection_set(iid)
                self.problem_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.problem_menu.grab_release()

    def _copy_problem_merged(self):
        item = self.problem_tree.focus()
        vals = self.problem_tree.item(item, "values")
        if not vals:
            return
        k = vals[0] if len(vals) >= 1 else None
        if not k:
            return
        text = self.ctrl.build_problem_merged_text(self.ctrl.extractor, k)
        if text:
            self._copy_to_clipboard(text)

    def _copy_problem_part(self, part: str):
        item = self.problem_tree.focus()
        vals = self.problem_tree.item(item, "values")
        if not vals:
            return
        k = vals[0]
        text = self.ctrl.build_problem_part_text(self.ctrl.extractor, k, part)
        if text:
            self._copy_to_clipboard(text)

    # ---------------------------------------------------------------------
    # 替换功能（标记对）
    # ---------------------------------------------------------------------

    def _refresh_marker_pairs(self):
        """
        扫描标记对并刷新下拉 + 右侧分屏（严格以“当前编辑器文本”为准，不叠加历史）。
        """
        current = self._get_editor_text()

        # 同步 Controller 的当前文本（不落盘）
        self.ctrl.update_current_text_only(current)
        display = self.ctrl.update_marker_pairs_from_text(current)

        # View 侧解析（用于右侧分栏）
        pairs = self._parse_marker_pairs(current)  # [{'label':..., 'content':...}, ...]

        # 下拉框刷新
        labels = [p["label"] for p in pairs] or display
        if hasattr(self, "pair_combo"):
            self.pair_combo["values"] = labels
            if labels:
                self.selected_pair_display.set(labels[0])
            else:
                self.selected_pair_display.set("")

        # 分栏按“当前标签个数”重建（不递增）
        self._rebuild_replace_blocks(pairs)

        # 若选择了项，联动定位
        if labels:
            self.on_pair_select()

    def _parse_marker_pairs(self, text: str):
        """
        解析形如
            <-----标签----->
            ...内容...
            <-----标签----->
        的成对标记，返回 [{'label': str, 'content': str}, ...]
        """
        pat = re.compile(r"^\s*<-----([^-\n]+)----->\s*$", re.M)
        pairs = []
        opened = {}

        for m in pat.finditer(text):
            label = m.group(1).strip()
            if label in opened:  # 关闭并成对
                start = opened.pop(label).end()
                end = m.start()
                content = text[start:end]
                pairs.append({"label": label, "content": content})
            else:
                opened[label] = m
        return pairs

    def _rebuild_replace_blocks(self, pairs):
        """
        根据解析到的标记对数量，重建右侧分屏块。
        每块：标题（label）+ 可编辑 ScrolledText（预填原内容）。
        先彻底清理旧 Pane，避免历史递增。
        """
        # 彻底清空旧 pane
        for w in list(self.replace_paned.winfo_children()):
            try:
                self.replace_paned.forget(w)
            except Exception:
                pass
            try:
                w.destroy()
            except Exception:
                pass
        self.replace_blocks = []

        if not pairs:
            # 没有标记就给一个空块，防止页面空白
            frame = ttk.Frame(self.replace_paned, padding=(6, 4))
            self.replace_paned.add(frame, weight=1)
            ttk.Label(frame, text="（未发现标记对）", bootstyle="secondary").pack(anchor="w")
            txt = ScrolledText(frame, wrap="word")
            txt.pack(fill="both", expand=True)
            self.replace_blocks.append(("未发现标记对", txt))

            # NEW: 允许把文件拖到这个空块
            try:
                txt.drop_target_register(DND_FILES)
                txt.dnd_bind(
                    "<<Drop>>",
                    lambda e, lab="未发现标记对", widget=txt: self._on_drop_file_to_block(e, lab, widget),
                )
            except Exception:
                pass
            return

        # 有 N 个标记对 -> N 个分屏块
        for p in pairs:
            frame = ttk.Frame(self.replace_paned, padding=(6, 4))
            self.replace_paned.add(frame, weight=1)
            ttk.Label(frame, text=p["label"]).pack(anchor="w")
            txt = ScrolledText(frame, wrap="word")
            txt.pack(fill="both", expand=True)
            txt.insert("1.0", p["content"].strip())
            self.replace_blocks.append((p["label"], txt))

            # NEW: 允许把文件拖到具体分屏块，覆盖其内容
            try:
                txt.drop_target_register(DND_FILES)
                txt.dnd_bind(
                    "<<Drop>>",
                    lambda e, lab=p["label"], widget=txt: self._on_drop_file_to_block(e, lab, widget),
                )
            except Exception:
                pass


    def on_pair_select(self, *_):
        """
        下拉选择某个标记时，把焦点定位到对应的分屏编辑框；
        若该标记对应块存在，则选中其全部内容，方便直接粘贴覆盖。
        """
        sel = (self.selected_pair_display.get() or "").strip()
        if not sel:
            return

        # 找到对应的分屏块（txt 是 ScrolledText）
        txt = self._find_block_by_label(sel)
        if not txt:
            return

        try:
            txt.focus_set()
            txt.tag_add("sel", "1.0", "end")  # 选中整块，便于直接粘贴
            txt.see("1.0")
        except Exception:
            pass

    def _find_block_by_label(self, label: str):
        """
        在 self.replace_blocks 中按标签名查找对应的文本控件。
        self.replace_blocks 的元素结构为 (label, text_widget)。
        """
        for lab, txt in getattr(self, "replace_blocks", []):
            if lab == label:
                return txt
        return None

    def apply_replace(self):
        """
        仅应用“下拉选中的那个标记”的替换：读取对应分屏块中的内容，写回整篇到编辑器。
        """
        sel = (self.selected_pair_display.get() or "").strip()
        if not sel:
            return
        try:
            txt = self._find_block_by_label(sel)
            if not txt:
                return
            new_content = txt.get("1.0", "end-1c")
            base_text = self._get_editor_text()
            new_text = self.ctrl.apply_replace_for_display(base_text, sel, new_content)
            self._editor_set_text(new_text)
            self._refresh_marker_pairs()
        except Exception as e:
            messagebox.showerror("错误", f"替换失败: {str(e)}")

    def apply_replace_all(self):
        """
        读取右侧每一块的文本，按‘标签’依次替换回整篇。
        逐块调用 Controller.apply_replace_for_display，避免自己拼正则。
        """
        base_text = self._get_editor_text()
        new_text = base_text
        for label, txt in self.replace_blocks:
            content = txt.get("1.0", "end-1c")
            new_text = self.ctrl.apply_replace_for_display(new_text, label, content)

        self._editor_set_text(new_text)
        self._refresh_marker_pairs()

    # ---------------------------------------------------------------------
    # 辅助页：文件列表/读取/插入
    # ---------------------------------------------------------------------
    def _aid_dir_path(self):
        return self.ctrl.aid_dir()

    def _refresh_aid_files(self):
        files = self.ctrl.list_aid_txt()
        self.aid_combo["values"] = files
        if not files:
            self.aid_selected.set("")
            self.aid_view.delete(1.0, "end")
        else:
            cur = self.aid_selected.get()
            if cur not in files:
                self.aid_selected.set(files[0])
            self._on_aid_select()

    def _on_aid_select(self):
        fname = self.aid_selected.get().strip()
        self.aid_view.delete(1.0, "end")
        if not fname:
            return
        try:
            txt = self.ctrl.read_aid_txt(fname)
        except Exception as e:
            txt = f"(读取失败：{e})"
        self.aid_view.insert("end", txt)

    def apply_aid_to_editor(self):
        """
        将辅助区当前内容“覆盖写入”编辑器（不再插入/叠加）；
        然后按新文本重新**扫描标签并重建分栏**，保证不递增。
        """
        content = self.aid_view.get(1.0, "end-1c")

        # 1) 覆盖写入编辑器 & 焦点
        self.notebook.select(self.tab_edit)
        self._editor_set_text(content)
        self.editor.focus_set()
        self.editor.mark_set(INSERT, "1.0")

        # 2) 同步到 Controller（不落盘），重建解析/树/分栏
        self.ctrl.update_current_text_only(content)
        self._refresh_marker_pairs()
        self._rebuild_all_trees()

        # 3) 直接切到“替换”页，便于马上编辑各块
        self.notebook.select(self.tab_replace)

    # ---------------------------------------------------------------------
    # Agent 集成：回调/动作
    # ---------------------------------------------------------------------
    def _agent_set_status(self, s: str):
        self.agent_status_var.set(str(s))

    def _agent_log(self, text: str):
        self.agent_console.config(state="normal")
        self.agent_console.insert("end", text)
        self.agent_console.see("end")
        self.agent_console.config(state="disabled")

    def _agent_connect(self):
        url = self.agent_url.get().strip()
        token = self.agent_token.get().strip() or None
        proxy = self.agent_proxy.get().strip() or None
        try:
            self.ctrl.agent_connect(
                url=url, token=token, proxy=proxy, ping_interval=20.0, insecure_skip_tls_verify=True
            )
            self._agent_log(f"> CONNECT {url}\n")
        except Exception as e:
            messagebox.showerror("连接失败", str(e))

    def _agent_close(self):
        try:
            self.ctrl.agent_close()
            self._agent_log("> CLOSE\n")
        except Exception as e:
            messagebox.showerror("断开失败", str(e))

    def _agent_ping(self):
        try:
            self.ctrl.agent_send_json({"type": "ping", "ts": time.time()})
            self._agent_log("> ping\n")
        except Exception as e:
            messagebox.showerror("发送失败", str(e))

    def _agent_infer(self):
        """示例：同步请求-响应。"""
        try:
            resp = self.ctrl.agent_request({"type": "infer", "payload": {"text": "hello mcmaa"}}, timeout=15.0)
            self._agent_log(f"> infer hello mcmaa\n< {resp}\n")
        except Exception as e:
            messagebox.showerror("请求失败", str(e))

    # ---------------------------------------------------------------------
    # 编辑器：全文搜索 / 替换对话框
    # ---------------------------------------------------------------------
    def _clear_search_tags(self):
        self.editor.tag_delete("search_hit")
        self.editor.tag_configure("search_hit", background="#ffd54f")

    def _do_find_all(self, needle: str) -> int:
        self._clear_search_tags()
        if not needle:
            return 0
        idx = "1.0"
        count = 0
        while True:
            idx = self.editor.search(needle, idx, nocase=False, stopindex=END)
            if not idx:
                break
            lastidx = f"{idx}+{len(needle)}c"
            self.editor.tag_add("search_hit", idx, lastidx)
            idx = lastidx
            count += 1
        if count:
            self.editor.see("search_hit.first")
        return count

    def _open_find_dialog(self):
        top = Toplevel(self)
        top.title("查找 (Ctrl+F)")
        top.transient(self.winfo_toplevel())
        top.resizable(False, False)

        ttk.Label(top, text="查找内容:").grid(row=0, column=0, padx=8, pady=8, sticky="w")
        var_find = StringVar()
        ttk.Entry(top, textvariable=var_find, width=40).grid(row=0, column=1, padx=8, pady=8)
        msg = ttk.Label(top, text="", bootstyle="secondary")
        msg.grid(row=1, column=0, columnspan=2, padx=8, pady=(0, 8), sticky="w")

        def do_find():
            n = self._do_find_all(var_find.get())
            msg.config(text=f"匹配 {n} 处")

        ttk.Button(top, text="查找全部并高亮", command=do_find).grid(row=0, column=2, padx=8, pady=8)
        top.bind("<Return>", lambda e: do_find())
        top.protocol("WM_DELETE_WINDOW", top.destroy)

    def _open_replace_dialog(self):
        top = Toplevel(self)
        top.title("替换 (Ctrl+H)")
        top.transient(self.winfo_toplevel())
        top.resizable(False, False)

        var_find = StringVar()
        var_repl = StringVar()

        ttk.Label(top, text="查找:").grid(row=0, column=0, padx=8, pady=8, sticky="w")
        e_find = ttk.Entry(top, textvariable=var_find, width=42)
        e_find.grid(row=0, column=1, padx=8, pady=8)
        e_find.focus_set()

        ttk.Label(top, text="替换为:").grid(row=1, column=0, padx=8, pady=8, sticky="w")
        e_repl = ttk.Entry(top, textvariable=var_repl, width=42)
        e_repl.grid(row=1, column=1, padx=8, pady=8)

        msg = ttk.Label(top, text="", bootstyle="secondary")
        msg.grid(row=2, column=0, columnspan=3, padx=8, pady=(0, 8), sticky="w")

        def replace_next():
            needle = var_find.get()
            if not needle:
                return
            idx = self.editor.index(INSERT)
            pos = self.editor.search(needle, idx, nocase=False, stopindex=END)
            if not pos:
                pos = self.editor.search(needle, "1.0", nocase=False, stopindex=END)
                if not pos:
                    msg.config(text="未找到")
                    return
            last = f"{pos}+{len(needle)}c"
            self.editor.delete(pos, last)
            self.editor.insert(pos, var_repl.get())
            self.editor.mark_set(INSERT, f"{pos}+{len(var_repl.get())}c")
            msg.config(text="已替换 1 处")

        def replace_all():
            needle = var_find.get()
            repl = var_repl.get()
            if not needle:
                return
            text = self._get_editor_text()
            count = text.count(needle)
            if count == 0:
                msg.config(text="未找到")
                return
            text = text.replace(needle, repl)
            self._editor_set_text(text)
            msg.config(text=f"已替换 {count} 处")

        ttk.Button(top, text="替换下一个", command=replace_next).grid(row=0, column=2, padx=8, pady=8)
        ttk.Button(top, text="全部替换", command=replace_all).grid(row=1, column=2, padx=8, pady=8)
        top.bind("<Return>", lambda e: replace_next())
        top.protocol("WM_DELETE_WINDOW", top.destroy)

    # ---------------------------------------------------------------------
    # 工具与杂项
    # ---------------------------------------------------------------------
    def _on_global_save_or_apply(self, _event=None):
        """统一 Ctrl/⌘+S 行为：替换页=应用替换；辅助页=插入；其余=保存。"""
        try:
            tab_text = self.notebook.tab(self.notebook.select(), "text")
        except Exception:
            tab_text = ""
        if tab_text == "替换":
            self.apply_replace()
        elif tab_text == "辅助":
            self.apply_aid_to_editor()
        else:
            self.save_current_text()
        return "break"

    def set_preview(self, text: str):
        self.notebook.select(self.tab_preview)
        self.preview.config(state="normal")
        self.preview.delete(1.0, "end")
        self.preview.insert("end", text)
        self.preview.config(state="disabled")

    def _get_editor_text(self) -> str:
        return self.editor.get(1.0, "end-1c")

    def _editor_set_text(self, s: str) -> None:
        self.editor.delete(1.0, "end")
        self.editor.insert("end", s)

    def _select_all(self, target=None):
        """支持两种调用：作为事件 (_select_all(event)) 或直接传控件 (_select_all(widget))。"""
        widget = None
        if hasattr(target, "widget"):
            widget = target.widget
        elif target is not None:
            widget = target
        else:
            return "break"
        try:
            widget.tag_add("sel", "1.0", "end")
        except Exception:
            pass
        return "break"

    def _copy_to_clipboard(self, s: str):
        try:
            top = self.winfo_toplevel()
            top.clipboard_clear()
            top.clipboard_append(s)
            top.update_idletasks()
        except Exception:
            pass

    # ==============================
    # Drag & Drop: 文件导入逻辑
    # ==============================
    def _safe_read_text_file(self, path: str) -> str:
        """尝试多种编码读取文本文件。"""
        for enc in ("utf-8", "utf-8-sig", "gbk", "ansi"):
            try:
                with open(path, "r", encoding=enc, errors="strict") as f:
                    return f.read()
            except Exception:
                continue
        # 最后兜底：忽略非法字符
        with open(path, "r", encoding="utf-8", errors="ignore") as f:
            return f.read()

    def _split_dnd_file_list(self, data: str):
        """
        DND_FILES 传入形如：'{C:\\a b\\c.txt} D:\\x.md' 这样的列表。
        用 Tk 的 splitlist 更稳，但这里以最通用方式兼容。
        """
        try:
            # Tk 自带解析（可用时最稳）
            return self.tk.splitlist(data)
        except Exception:
            # 退化解析：去大括号并按空格拆（不含空格路径则 OK）
            s = data.replace("{", "").replace("}", "")
            return [p for p in s.split() if p]

    def _on_drop_file_to_block(self, event, label: str, widget):
        """
        把文件拖到某个具体分屏块：该块的文本将被拖入文件的内容覆盖（多个文件则依次拼接）。
        """
        paths = self._split_dnd_file_list(event.data)
        if not paths:
            return

        contents = []
        for path in paths:
            try:
                text = self._safe_read_text_file(path)
                contents.append(text.strip())
            except Exception as e:
                messagebox.showerror("导入失败", f"读取文件失败：{e}")
                return

        merged_text = "\n\n".join(contents)

        # 覆盖该块文本
        try:
            widget.delete("1.0", "end")
            widget.insert("1.0", merged_text)
            widget.focus_set()
            widget.tag_add("sel", "1.0", "end")
        except Exception as e:
            messagebox.showerror("导入失败", str(e))


    def _on_drop_files_to_replace_page(self, event):
        """
        把文件拖到“替换”页空白处/顶部栏：
        - 每个文件逐一解析：
          - 若文件内含 <-----标签-----> ... <-----标签----->，按标签名自动分发到各块；
          - 若不含标记：累积，最后统一填充到当前下拉选中的块。
        """
        paths = self._split_dnd_file_list(event.data)
        if not paths:
            return

        exist_labels = {lab: txt for lab, txt in getattr(self, "replace_blocks", [])}
        hit = 0
        free_texts = []

        for path in paths:
            try:
                text = self._safe_read_text_file(path)
            except Exception as e:
                messagebox.showerror("导入失败", f"读取文件失败：{e}")
                return

            pairs = self._parse_marker_pairs(text)
            if pairs:
                for p in pairs:
                    lab = p["label"]
                    if lab in exist_labels:
                        txt = exist_labels[lab]
                        txt.delete("1.0", "end")
                        txt.insert("1.0", p["content"].strip())
                        hit += 1
            else:
                free_texts.append(text.strip())

        if hit > 0:
            self.notebook.select(self.tab_replace)
            first_label = next((lab for lab in exist_labels if exist_labels[lab].get("1.0", "end").strip()), None)
            if first_label:
                self.selected_pair_display.set(first_label)
                self.on_pair_select()
            messagebox.showinfo("成功", f"已自动填充 {hit} 个分屏块。")

        if free_texts:
            sel = (self.selected_pair_display.get() or "").strip()
            target_txt = self._find_block_by_label(sel) if sel else None
            if target_txt:
                merged_text = "\n\n".join(free_texts)
                target_txt.delete("1.0", "end")
                target_txt.insert("1.0", merged_text)
                target_txt.focus_set()
                target_txt.tag_add("sel", "1.0", "end")
                messagebox.showinfo("成功", f"已把 {len(free_texts)} 个文件内容填充到分屏块：{sel}")
            else:
                messagebox.showinfo(
                    "提示",
                    f"{len(free_texts)} 个文件不含标记对，且未选择具体分屏块；请先在下拉中选择目标块，或直接拖到某个具体分屏块。",
                )


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\screens\__init__.py 的内容:
================================================================================


