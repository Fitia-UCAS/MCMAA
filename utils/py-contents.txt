目录结构 (仅 .py 文件):
|-- 文件夹: controller
|   |-- 文件: workbench_controller.py
|-- 文件: main.py
|-- 文件夹: model
|   |-- 文件: latex_extractor.py
|   |-- 文件夹: prompts
|   |-- 文件: text_replacer.py
|-- 文件夹: service
|   |-- 文件夹: agents
|   |   |-- 文件: mathmodelagent_client.py
|-- 文件夹: utils
|   |-- 文件: clear_pycache.py
|   |-- 文件: paths.py
|   |-- 文件夹: template
|-- 文件夹: view
|   |-- 文件: common_widgets.py
|   |-- 文件: config.py
|   |-- 文件夹: screens
|   |   |-- 文件: screen_workbench.py


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\main.py 的内容:
================================================================================
# %% main.py
# -*- coding: utf-8 -*-

# 内置库
import os
import sys
import logging
from logging.handlers import RotatingFileHandler
from tkinter import Toplevel
import tkinter.messagebox as messagebox

# 第三方库
import ttkbootstrap as ttk

from view.config import DATA_CONFIG, SCREEN_CONFIG
from view.screens.screen_workbench import Screen_Workbench
from utils.clear_pycache import clear_pycache
from utils.paths import resource_path

# ========== 日志 ==========
logger = logging.getLogger()
logger.setLevel(logging.INFO)
_handler = RotatingFileHandler("app.log", mode="a", maxBytes=2 * 1024 * 1024, backupCount=3, encoding="utf-8")
_formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
_handler.setFormatter(_formatter)
logger.handlers = [_handler]


# 捕获未处理异常：写日志 + 弹窗提示
def _excepthook(exc_type, exc, tb):
    logging.exception("Uncaught exception", exc_info=(exc_type, exc, tb))
    try:
        messagebox.showerror("错误", f"发生未处理异常：{exc_type.__name__}: {exc}")
    except Exception:
        pass


sys.excepthook = _excepthook


# ========== 启动画面（ASCII Splash）==========
ASCII_MCMAA = r"""
        ,'  , `.  ,----..          ,'  , `.   ,---,         ,---,        
     ,-+-,.' _ | /   /   \      ,-+-,.' _ |  '  .' \       '  .' \       
  ,-+-. ;   , |||   :     :  ,-+-. ;   , || /  ;    '.    /  ;    '.     
 ,--.'|'   |  ;|.   |  ;. / ,--.'|'   |  ;|:  :       \  :  :       \    
|   |  ,', |  ':.   ; /--` |   |  ,', |  '::  |   /\   \ :  |   /\   \   
|   | /  | |  ||;   | ;    |   | /  | |  |||  :  ' ;.   :|  :  ' ;.   :  
'   | :  | :  |,|   : |    '   | :  | :  |,|  |  ;/  \   \  |  ;/  \   \ 
;   . |  ; |--' .   | '___ ;   . |  ; |--' '  :  | \  \ ,'  :  | \  \ ,' 
|   : |  | ,    '   ; : .'||   : |  | ,    |  |  '  '--' |  |  '  '--'   
|   : '  |/     '   | '/  :|   : '  |/     |  :  :       |  :  :         
;   | |`-'      |   :    / ;   | |`-'      |  | ,'       |  | ,'         
|   ;/           \   \ .'  |   ;/          `--''         `--''           
'---'             `---`    '---'                                         
"""


class Splash(Toplevel):
    def __init__(self, master, delay_ms=1200):
        super().__init__(master)
        # 无边框置顶
        self.overrideredirect(True)
        self.attributes("-topmost", True)

        # 内容
        frame = ttk.Frame(self, padding=24)
        frame.pack(fill="both", expand=True)
        # 使用等宽字体以显示 ASCII
        label = ttk.Label(frame, text=ASCII_MCMAA, font=("Consolas", 12), justify="left")
        label.pack()

        # 居中
        self.update_idletasks()
        w, h = self.winfo_width(), self.winfo_height()
        sw, sh = self.winfo_screenwidth(), self.winfo_screenheight()
        self.geometry(f"+{(sw - w) // 2}+{(sh - h) // 2}")

        # 延时关闭
        self.after(delay_ms, self.destroy)


# ========== 主屏 ==========
class Screen(ttk.Frame):
    """唯一主界面：写作工作台"""

    def __init__(self):
        super().__init__(DATA_CONFIG["window"], **SCREEN_CONFIG)
        DATA_CONFIG["screen"] = self
        self.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 直接加载合并后的工作台
        self.workbench = Screen_Workbench(self)
        # 给“同步预览”留一个开关（目前工作台始终同步，后续可在 set_preview 里读取此值）
        self.workbench.sync_preview = True
        self.workbench.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 菜单栏
        self._build_menubar()

    # ---------- 顶部极简菜单 ----------
    def _build_menubar(self):
        root = DATA_CONFIG["window"]
        menubar = ttk.Menu(root)

        # File
        m_file = ttk.Menu(menubar, tearoff=False)
        m_file.add_command(label="Open\tCtrl+O", command=self.workbench.select_file)
        m_file.add_command(label="Save\tCtrl+S", command=self.workbench.save_current_text)
        m_file.add_command(label="Reload", command=self.workbench.reload_from_disk)
        m_file.add_separator()

        # Quick Open 子菜单：用 postcommand 动态刷新
        self.quick_open_menu = ttk.Menu(m_file, tearoff=False, postcommand=self._refresh_quick_open)
        m_file.add_cascade(label="Quick Open", menu=self.quick_open_menu)

        menubar.add_cascade(label="File", menu=m_file)

        # View
        m_view = ttk.Menu(menubar, tearoff=False)
        self._sync_preview_var = ttk.BooleanVar(value=True)

        def _toggle_sync():
            # 目前 set_preview 会自动切换到“预览”，这里仅保存偏好，便于将来生效
            self.workbench.sync_preview = bool(self._sync_preview_var.get())

        m_view.add_checkbutton(
            label="Sync Preview", onvalue=True, offvalue=False, variable=self._sync_preview_var, command=_toggle_sync
        )
        menubar.add_cascade(label="View", menu=m_view)

        # Help
        m_help = ttk.Menu(menubar, tearoff=False)
        m_help.add_command(label="View Log", command=self._show_log_window)
        m_help.add_separator()
        m_help.add_command(label="About", command=self._about)
        menubar.add_cascade(label="Help", menu=m_help)

        root.config(menu=menubar)

    def _refresh_quick_open(self):
        # 先清空
        self.quick_open_menu.delete(0, "end")
        paths = self.workbench.get_recent_files()
        if not paths:
            self.quick_open_menu.add_command(label="(Empty)", state="disabled")
            return
        for p in paths:
            self.quick_open_menu.add_command(label=p, command=lambda _p=p: self.workbench.quick_open(_p))

    def _show_log_window(self):
        log_path = os.path.join(DATA_CONFIG.get("py_path") or ".", "app.log")
        try:
            with open(log_path, "r", encoding="utf-8") as f:
                content = f.read()
        except Exception as e:
            content = f"(无法读取日志: {e})"

        win = ttk.Toplevel(self)
        win.title("应用日志 app.log")
        win.geometry("900x600")
        txt = ttk.ScrolledText(win, wrap="word", state="normal")
        txt.pack(fill="both", expand=True)
        txt.insert("end", content)
        txt.config(state="disabled")

    def _about(self):
        messagebox.showinfo(
            "About",
            "MCM Aid Assistant v1.1.0\n\n"
            "极简写作工作台：左侧大纲/问题树，右侧编辑/预览/标记替换。\n"
            "快捷键：Ctrl+O 打开，Ctrl+S 保存，Ctrl+F 查找，Ctrl+H 替换。\n"
            "File→Quick Open 提供最近文件。",
        )


class App:
    """应用主体"""

    def __init__(self, py_path=os.path.dirname(os.path.abspath(__file__))):
        DATA_CONFIG["app"] = self
        DATA_CONFIG["py_path"] = py_path

        # 先创建主窗口，但先隐藏
        DATA_CONFIG["window"] = ttk.Window(
            themename="sandstone",
            title="数学建模论文写作辅助软件 MCM Aid Assistant v1.1.0",
        )
        root = DATA_CONFIG["window"]
        root.withdraw()

        # 图标
        try:
            if sys.platform.startswith("darwin"):
                root.iconphoto(True, ttk.PhotoImage(file=resource_path("mcmaa.png")))
            else:
                # Linux 用 iconphoto，更通用；Windows 可留 iconbitmap
                ico_path = resource_path("mcmaa.ico")
                if sys.platform.startswith("win"):
                    root.iconbitmap(ico_path)
                else:
                    root.iconphoto(True, ttk.PhotoImage(file=resource_path("mcmaa.png")))
        except Exception as e:
            logging.info(f"图标加载失败: {e}")

        # 尺寸
        min_height = 960
        min_width = int(min_height * 4 / 3)
        root.minsize(min_width, min_height)
        root.geometry(f"{min_width}x{min_height}")
        screen_height = root.winfo_screenheight()
        screen_width = root.winfo_screenwidth()
        default_height = int(screen_height * 0.75)
        default_width = int(screen_height * 0.75 * 4 / 3)
        if screen_height < min_height or screen_width < min_width:
            root.minsize(screen_width, screen_height)
            default_height = screen_height
            default_width = screen_width
            root.geometry(f"{default_width}x{default_height}")
        elif screen_height * 0.75 > min_height and screen_height * 0.75 * 4 / 3 > min_width:
            root.geometry(f"{default_width}x{default_height}")
        root.geometry("+0+0")

        # 显示启动 ASCII Splash
        splash = Splash(root, delay_ms=1200)

        # Splash 消失后显示主界面
        def _show_main():
            if splash.winfo_exists():
                try:
                    splash.destroy()
                except Exception:
                    pass
            root.deiconify()
            Screen()  # 创建主界面

        root.after(1250, _show_main)  # 稍微比 Splash 多 50ms，避免闪烁
        root.mainloop()


if __name__ == "__main__":
    App()
    script_dir = os.path.dirname(os.path.abspath(__file__))
    clear_pycache(script_dir)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\controller\workbench_controller.py 的内容:
================================================================================
# %% controller/workbench_controller.py
# -*- coding: utf-8 -*-

"""
WorkbenchController
===================

将“处理逻辑/业务逻辑”集中到 Controller，View 只负责显示与事件绑定。

职责边界：
- Controller 负责：文件读写、最近文件管理、LatexExtractor 构建与数据整形、
  标记对扫描与替换、辅助文本读取、纯内容片段提取（不含展示性分隔与文案）。
- View 负责：控件创建、布局、事件绑定、把用户输入/当前文本传给 Controller，
  并根据 Controller 返回的数据刷新界面（Treeview、文本框、消息提示等），
  同时负责生成所有用户可见的文案与分隔样式。

常用调用方式（示例，文案由 View 决定）：
- 打开文件：ctrl.open_path(path)  → 返回 {"text": 文本}
- 保存文件：ctrl.save_text(current_editor_text) → (ok, msg)；ok=True 时 msg 为空字符串
- 重载文件：ctrl.reload_from_disk() → {"text": 文本}
- 构建导航树：ctrl.make_outline_nodes(ctrl.extractor)、ctrl.make_problem_tree(ctrl.extractor)、
  ctrl.make_code_nodes(ctrl.extractor)  → 交给 View 填充 Treeview
- 预览：ctrl.render_outline_preview(...), ctrl.render_problem_preview(...), ctrl.render_code_preview(...)
- 替换页：
    ctrl.update_marker_pairs_from_text(editor_text) → 返回候选显示名列表
    ctrl.get_pair_content_by_display(sel_display)  → 返回已缓存/原始内容
    ctrl.apply_replace_for_display(editor_text, sel_display, new_content) → 返回 new_text
- 辅助页：
    files = ctrl.list_aid_txt()
    txt = ctrl.read_aid_txt(filename)

备注：
- 本 Controller 维护少量状态（current_file/current_text/extractor/recent_files 等），
  但不直接操作 UI；所有需要的输入（例如“当前编辑器文本”）在调用时作为参数传入。
"""

from __future__ import annotations

import os
import re
import pathlib
from typing import List, Dict, Any, Optional, Tuple

import appdirs

from model.latex_extractor import LatexExtractor
from model.text_replacer import find_marker_pairs, replace_contents
from utils.paths import resource_path


# ===== 常量 =====
RECENT_FILE_MAX = 5
RECENT_FILE_STORE = "recent_files.txt"


class WorkbenchController:
    """一体化工作台的业务控制器"""

    # ---------- 生命周期 / 状态 ----------
    def __init__(self) -> None:
        # 文件/文本相关
        self.current_file: Optional[str] = None
        self.current_text: str = ""
        self.extractor: Optional[LatexExtractor] = None

        # 最近文件
        self.recent_files: List[str] = self.load_recent()

        # 替换相关
        self.marker_pairs: List[Dict[str, Any]] = []
        self.replacements: Dict[int, str] = {}  # 以“标记对索引”为 key 的缓存替换文本

    # ---------- 最近文件：读写 ----------
    @staticmethod
    def _recent_store_path() -> str:
        """
        将最近文件记录存放到用户数据目录，跨平台更稳：
        Windows:  C:\\Users\\<User>\\AppData\\Local\\mcm\\mcmaa\\recent_files.txt
        macOS:    ~/Library/Application Support/mcmaa/recent_files.txt
        Linux:    ~/.local/share/mcmaa/recent_files.txt
        """
        app_dir = appdirs.user_data_dir(appname="mcmaa", appauthor="mcm")
        pathlib.Path(app_dir).mkdir(parents=True, exist_ok=True)
        return os.path.join(app_dir, RECENT_FILE_STORE)

    def load_recent(self) -> List[str]:
        path = self._recent_store_path()
        items: List[str] = []
        try:
            with open(path, "r", encoding="utf-8") as f:
                for line in f:
                    p = line.strip()
                    if p and os.path.exists(p):
                        items.append(p)
        except Exception:
            pass
        return items[:RECENT_FILE_MAX]

    def save_recent(self, items: List[str]) -> None:
        path = self._recent_store_path()
        try:
            with open(path, "w", encoding="utf-8") as f:
                for p in items[:RECENT_FILE_MAX]:
                    f.write(p + "\n")
        except Exception:
            pass

    def add_recent(self, p: Optional[str]) -> None:
        """更新最近文件列表并写盘"""
        if not p:
            return
        if p in self.recent_files:
            self.recent_files.remove(p)
        self.recent_files.insert(0, p)
        self.recent_files = self.recent_files[:RECENT_FILE_MAX]
        self.save_recent(self.recent_files)

    def remove_recent_if_missing(self, p: str) -> None:
        """当文件不存在时，从最近列表清理"""
        try:
            if p in self.recent_files:
                self.recent_files.remove(p)
                self.save_recent(self.recent_files)
        except Exception:
            pass

    # ---------- 文件 I/O ----------
    @staticmethod
    def read_file(path: str) -> str:
        with open(path, "r", encoding="utf-8") as f:
            return f.read()

    @staticmethod
    def write_file(path: str, content: str) -> None:
        with open(path, "w", encoding="utf-8") as f:
            f.write(content)

    # ---------- 打开/重载/保存：同时维护 extractor ----------
    def open_path(self, file_path: str) -> Dict[str, str]:
        """
        打开文件 -> 读取文本 -> 构建 extractor -> 维护最近文件。
        仅返回内容，不返回面向用户的 UI 文案。
        返回 {"text": 文本}
        """
        self.current_file = file_path
        text = self.read_file(file_path)
        self.current_text = text
        self.extractor = self.build_extractor(file_path, max_level=3)
        self.add_recent(file_path)
        # 开启新文件后，清空替换缓存 & 重新扫描标记
        self.replacements.clear()
        self.update_marker_pairs_from_text(text)
        return {"text": text}

    def reload_from_disk(self) -> Dict[str, str]:
        """
        从磁盘重载当前文件，不改动磁盘文件，只更新内存文本与 extractor。
        返回 {"text": 文本}（不返回 UI 文案）
        """
        if not self.current_file:
            return {"text": ""}
        text = self.read_file(self.current_file)
        self.current_text = text
        self.extractor = self.build_extractor(self.current_file, max_level=3)
        # 保持替换缓存策略简单：重载时清空，避免索引错位
        self.replacements.clear()
        self.update_marker_pairs_from_text(text)
        return {"text": text}

    def save_text(self, editor_text: str) -> Tuple[bool, str]:
        """
        保存编辑器文本到当前文件，并重建 extractor。
        成功时返回 (True, "") —— 留空文案交由 View 决定；
        失败时返回 (False, 技术错误字符串) —— 由 View 决定如何组织对用户的提示。
        """
        if not self.current_file:
            return False, "no file opened"
        try:
            self.write_file(self.current_file, editor_text)
            self.current_text = editor_text
            self.extractor = self.build_extractor(self.current_file, max_level=3)
            self.add_recent(self.current_file)
            # 保存后不强制清空 replacements；索引变化会在下一次扫描时自然覆盖
            self.update_marker_pairs_from_text(editor_text)
            return True, ""  # 文案交由 View
        except Exception as e:
            return False, str(e)  # 技术信息，非 UI 文案

    # ---------- 模型 ----------
    @staticmethod
    def build_extractor(tex_path: str, max_level: int = 3) -> LatexExtractor:
        return LatexExtractor(tex_path, max_level=max_level)

    # ---------- 导航树数据（仅数据组装，View 自行渲染） ----------
    @staticmethod
    def make_outline_nodes(extractor: Optional[LatexExtractor]) -> List[Dict[str, Any]]:
        """
        生成大纲节点数据（不含 codeblock）：
        返回列表，每个元素：{"title": str, "level": int, "line_num": int}
        视图侧按 level 构建层级关系。
        """
        nodes: List[Dict[str, Any]] = []
        if not extractor:
            return nodes
        for section_type, title, level, line_num in extractor.sections:
            if section_type == "codeblock":
                continue
            nodes.append({"title": title, "level": level, "line_num": line_num})
        return nodes

    @staticmethod
    def make_problem_tree(extractor: Optional[LatexExtractor]) -> List[Dict[str, Any]]:
        """
        生成问题树数据（结构化数据，文案与展示由 View 决定）：
        返回：
        [
          {"text": f"问题{k}", "values": (k,), "children": [
                {"text":"摘要片段", "values":(k, "abstract")},
                {"text":"问题重述","values":(k, "restate")},
                {"text":"问题分析","values":(k, "analysis")},
                {"text":"模型与求解","values":(k, "modeling")},
          ]},
          ...
        ]
        """
        items: List[Dict[str, Any]] = []
        if not extractor:
            return items
        try:
            keywords = extractor.get_unique_keywords()
        except Exception:
            keywords = []
        for k in keywords:
            node = {
                "text": f"问题{k}",
                "values": (k,),
                "children": [
                    {"text": "摘要片段", "values": (k, "abstract")},
                    {"text": "问题重述", "values": (k, "restate")},
                    {"text": "问题分析", "values": (k, "analysis")},
                    {"text": "模型与求解", "values": (k, "modeling")},
                ],
            }
            items.append(node)
        return items

    @staticmethod
    def make_code_nodes(extractor: Optional[LatexExtractor]) -> List[Dict[str, Any]]:
        """
        生成代码树节点数据（只列出 codeblock，保持出现顺序）：
        返回列表，每个元素：{"text": title, "values": (start_line, 4)}
        """
        nodes: List[Dict[str, Any]] = []
        if not extractor:
            return nodes
        for cb in extractor.codeblocks:
            nodes.append({"text": cb["title"], "values": (cb["start"], 4)})
        return nodes

    # ---------- 预览渲染（仅内容拼接，不做展示性分隔） ----------
    @staticmethod
    def render_outline_preview(
        extractor: Optional[LatexExtractor],
        start_line: int,
        start_level: int,
    ) -> str:
        """大纲点击后的预览：从起始行到下一个同级/更高级标题"""
        if not extractor:
            return ""
        lines = extractor.extract_content(start_line, start_level)
        return "\n".join(lines)

    def render_code_preview(
        self,
        extractor: Optional[LatexExtractor],
        start_line: int,
        level: int,
    ) -> str:
        """代码树点击后的预览：直接复用提取"""
        return self.render_outline_preview(extractor, start_line, level)

    @staticmethod
    def render_problem_preview(
        extractor: Optional[LatexExtractor],
        k: str,
        part: Optional[str] = None,
    ) -> str:
        """
        问题树项点击后的预览：
        - part 为 None：合并“摘要片段/重述/分析/建模”，不插入展示性分隔，交由 View 决定呈现样式
        - part in {"abstract","restate","analysis","modeling"}：只返回对应部分
        """
        if not extractor or not k:
            return ""
        parts = extractor.extract_problem_parts(k)
        abstract = extractor.extract_abstract_parts(k)

        if part is None:
            merged: List[str] = []
            if abstract:
                merged += abstract + [""]

            if "Restatement" in parts:
                merged += parts["Restatement"] + [""]

            if "Analysis" in parts:
                merged += parts["Analysis"] + [""]

            if "Modeling" in parts:
                merged += parts["Modeling"] + [""]

            return "\n".join(merged).strip() or ""

        # 单部分
        if part == "abstract":
            content = abstract
        elif part == "restate":
            content = parts.get("Restatement", [])
        elif part == "analysis":
            content = parts.get("Analysis", [])
        elif part == "modeling":
            content = parts.get("Modeling", [])
        else:
            content = []
        return "\n".join(content).strip()

    # ---------- 复制文本（供 View 放入剪贴板，保持纯内容） ----------
    @staticmethod
    def build_problem_merged_text(extractor: Optional[LatexExtractor], k: str) -> str:
        if not extractor or not k:
            return ""
        parts = extractor.extract_problem_parts(k)
        abstract = extractor.extract_abstract_parts(k)

        merged: List[str] = []
        if abstract:
            merged += abstract + [""]

        if "Restatement" in parts:
            merged += parts["Restatement"] + [""]

        if "Analysis" in parts:
            merged += parts["Analysis"] + [""]

        if "Modeling" in parts:
            merged += parts["Modeling"] + [""]

        return "\n".join(merged).strip()

    @staticmethod
    def build_problem_part_text(extractor: Optional[LatexExtractor], k: str, part: str) -> str:
        if not extractor or not k:
            return ""
        if part == "abstract":
            content = extractor.extract_abstract_parts(k)
        else:
            mapping = {"restate": "Restatement", "analysis": "Analysis", "modeling": "Modeling"}
            pieces = extractor.extract_problem_parts(k)
            content = pieces.get(mapping.get(part, ""), [])
        return "\n".join(content).strip()

    # ---------- 替换功能 ----------
    @staticmethod
    def _marker_display_name(marker_type: str) -> str:
        """
        将 “<----- xxx ----->” 提取为 “xxx”；若不匹配则返回原串。
        """
        m = re.search(r"<-----(.*?)----->", marker_type)
        return m.group(1).strip() if m else marker_type

    def update_marker_pairs_from_text(self, text: str) -> List[str]:
        """
        扫描标记对，更新 self.marker_pairs，并返回“可供下拉选择的显示名列表”。
        注意：下拉项可能不唯一（如果模板里有相同的 marker_type），此处保持与旧实现一致。
        """
        self.marker_pairs = find_marker_pairs(text)
        display = [self._marker_display_name(p["marker_type"]) for p in self.marker_pairs]
        return display

    def get_pair_content_by_display(self, display_name: str) -> str:
        """
        根据显示名找到对应标记对，返回“已缓存替换文本”或“原始内容”。
        规则与原实现一致：优先返回 self.replacements[idx]，否则返回 pair["content"]。
        """
        display_name = (display_name or "").strip()
        if not display_name:
            return ""
        for pair in self.marker_pairs:
            disp = self._marker_display_name(pair["marker_type"])
            if disp == display_name:
                idx = pair["index"]
                return self.replacements.get(idx, pair.get("content", ""))
        return ""

    def apply_replace_for_display(self, base_text: str, display_name: str, new_content: str) -> str:
        """
        对“当前选择的标记对”应用替换，返回新的整篇文本（View 写回到编辑器即可）。
        - base_text：通常是编辑器里的完整文本
        - display_name：下拉选中的项（例如 “摘要/关键词/引言” 等）
        - new_content：替换区域的完整新文本
        """
        display_name = (display_name or "").strip()
        if not display_name:
            return base_text

        # 1) 通过显示名定位 index
        idx: Optional[int] = None
        for pair in self.marker_pairs:
            disp = self._marker_display_name(pair["marker_type"])
            if disp == display_name:
                idx = pair["index"]
                break
        if idx is None:
            return base_text

        # 2) 记录到缓存并做整体替换
        self.replacements[idx] = new_content
        new_text = replace_contents(base_text, self.replacements)

        # 3) 替换后重新扫描标记对（索引可能重排）
        self.update_marker_pairs_from_text(new_text)
        return new_text

    # ---------- 辅助页 ----------
    @staticmethod
    def aid_dir() -> str:
        """
        返回 utils/ai-aid-mcmaa 目录（支持 pyinstaller 后的资源路径）
        """
        return resource_path("utils", "ai-aid-mcmaa")

    def list_aid_txt(self) -> List[str]:
        d = self.aid_dir()
        out: List[str] = []
        try:
            if os.path.isdir(d):
                for name in os.listdir(d):
                    if name.lower().endswith(".txt"):
                        out.append(name)
        except Exception:
            pass
        out.sort()
        return out

    def read_aid_txt(self, filename: str) -> str:
        fpath = os.path.join(self.aid_dir(), filename)
        with open(fpath, "r", encoding="utf-8") as f:
            return f.read()

    # ---------- Quick Open：供菜单调用 ----------
    def quick_open(self, p: Optional[str]) -> Tuple[bool, str, str]:
        """
        给“Quick Open”使用：
        - 路径为空或文件不存在：返回 (False, 技术原因字符串, "")
        - 成功：等价于 open_path，返回 (True, "", text)
        （不返回 UI 文案，由 View 决定展示“文件已加载: ...”等）
        """
        if not p or not os.path.exists(p):
            self.remove_recent_if_missing(p or "")
            return False, "file not found or removed", ""
        data = self.open_path(p)
        return True, "", data.get("text", "")

    # ---------- 工具：将 Editor 的文本更新到 Controller（不保存磁盘） ----------
    def update_current_text_only(self, editor_text: str) -> None:
        """
        View 在需要时可以调用该方法同步“当前编辑器内容”到 Controller。
        注意：该方法不会写入磁盘，也不会重建 extractor。
        主要用于替换页/辅助页等需要 Controller 暂存当前文本参与计算的场景。
        """
        self.current_text = editor_text


# -*- coding: utf-8 -*-
"""
AgentBridge — 将 MathModelAgentClient 接入到 WorkbenchController 的最小适配层
================================================================================
使用方式
--------
1) 将本文件保存为：controller/agent_bridge.py
2) 修改 controller/workbench_controller.py：
   - 增加导入：
       from controller.agent_bridge import AgentBridge
   - 让 WorkbenchController 继承该混入：
       class WorkbenchController(AgentBridge):
           def __init__(self):
               AgentBridge.__init__(self)
               ... 原有初始化 ...
3) 在 View 层注册回调（示例）——比如在 Screen_Workbench.__init__ 里：
       ctrl.set_agent_handlers(
           on_status=lambda s: self._show_status(s),
           on_message=lambda m: self._append_console(m),
           on_error=lambda e: self._show_error(e),
       )
4) 连接与发送：
       ctrl.agent_connect(url, token="xxx")
       ctrl.agent_send_json({"type":"ping"})
       resp = ctrl.agent_request({"type":"infer","payload":{"text":"hello"}}, timeout=15)

备注
----
- 采用后台线程 + 回调通知；回调均在接收线程里触发，如需切 UI 线程请在 View 层自行调度（tkinter 用 after）。
- 维护最近 N 条消息缓存（默认 200）以便 View 拉取。
- 仅依赖 service.agents.mathmodelagent_client.MathModelAgentClient。
"""
from __future__ import annotations

from typing import Any, Callable, Deque, Dict, Optional
from collections import deque
import logging
import ssl
import time

from service.agents.mathmodelagent_client import MathModelAgentClient

logger = logging.getLogger(__name__)


class AgentBridge:
    """为控制器提供与 Agent 的连接/通信能力（Mixin）。"""

    # ------------------------ 生命周期 / 状态 ------------------------
    def __init__(self) -> None:
        # 运行态
        self._agent: Optional[MathModelAgentClient] = None
        self._agent_connected: bool = False
        self._agent_last_status: str = "disconnected"
        self._agent_last_error: Optional[str] = None
        self._agent_msgs: Deque[Any] = deque(maxlen=200)

        # 回调（由 View 注入）
        self._cb_on_status: Optional[Callable[[str], None]] = None
        self._cb_on_message: Optional[Callable[[Any], None]] = None
        self._cb_on_error: Optional[Callable[[str], None]] = None

    # ------------------------ 回调注册 ------------------------
    def set_agent_handlers(
        self,
        on_status: Optional[Callable[[str], None]] = None,
        on_message: Optional[Callable[[Any], None]] = None,
        on_error: Optional[Callable[[str], None]] = None,
    ) -> None:
        self._cb_on_status = on_status
        self._cb_on_message = on_message
        self._cb_on_error = on_error

    # ------------------------ 连接管理 ------------------------
    def agent_connect(
        self,
        url: str,
        token: Optional[str] = None,
        proxy: Optional[str] = None,
        ping_interval: float = 20.0,
        insecure_skip_tls_verify: bool = False,
    ) -> None:
        """建立到 Agent 的 WebSocket 连接。后台线程运行。"""
        self.agent_close()

        sslopt = {"cert_reqs": ssl.CERT_NONE} if insecure_skip_tls_verify else None
        self._agent = MathModelAgentClient(
            url=url,
            token=token,
            proxy=proxy,
            ping_interval=ping_interval,
            sslopt=sslopt,
        )

        # 绑定底层回调
        @self._agent.on_open
        def _opened():
            self._agent_connected = True
            self._set_status("connected")

        @self._agent.on_message
        def _message(m):
            self._agent_msgs.append({"ts": time.time(), "data": m})
            if self._cb_on_message:
                try:
                    self._cb_on_message(m)
                except Exception as e:  # noqa
                    logger.debug("on_message UI cb error: %s", e)

        @self._agent.on_error
        def _error(e: Exception):
            self._agent_last_error = str(e)
            self._set_status("error")
            if self._cb_on_error:
                try:
                    self._cb_on_error(self._agent_last_error)
                except Exception:  # noqa
                    pass

        @self._agent.on_close
        def _closed(code: int, msg: str):
            self._agent_connected = False
            self._set_status(f"closed({code})")

        @self._agent.on_reconnect
        def _reconn(attempt: int, delay: float):
            self._set_status(f"reconnecting #{attempt} in {delay:.1f}s")

        # 后台线程启动
        self._set_status("connecting...")
        self._agent.connect(block=False)

    def agent_close(self) -> None:
        if self._agent:
            try:
                self._agent.close()
            except Exception:  # noqa
                pass
            finally:
                self._agent = None
        self._agent_connected = False
        self._set_status("disconnected")

    def agent_is_connected(self) -> bool:
        return bool(self._agent and self._agent.is_connected())

    # ------------------------ 发送 API ------------------------
    def agent_send_text(self, text: str) -> None:
        if not self._agent:
            raise RuntimeError("agent not connected")
        self._agent.send_text(text)

    def agent_send_json(self, payload: Dict[str, Any]) -> None:
        if not self._agent:
            raise RuntimeError("agent not connected")
        self._agent.send_json(payload)

    def agent_request(self, payload: Dict[str, Any], timeout: float = 15.0) -> Any:
        if not self._agent:
            raise RuntimeError("agent not connected")
        return self._agent.request(payload, timeout=timeout)

    # ------------------------ 消息缓存（可选给 View 拉取） ------------------------
    def agent_recent_messages(self, limit: int = 50) -> list[Any]:
        """返回最近收到的消息（新 → 旧）。"""
        out = list(self._agent_msgs)
        out.reverse()
        return out[:limit]

    def agent_last_error(self) -> Optional[str]:
        return self._agent_last_error

    def agent_status(self) -> str:
        return self._agent_last_status

    # ------------------------ 内部：状态 & 回调封装 ------------------------
    def _set_status(self, status: str) -> None:
        self._agent_last_status = status
        if self._cb_on_status:
            try:
                self._cb_on_status(status)
            except Exception:  # noqa
                pass


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\model\latex_extractor.py 的内容:
================================================================================
# %% model/latex_extractor.py
# -*- coding: utf-8 -*-

import re


class LatexExtractor:
    def __init__(self, file_path, max_level=4):
        """Initialize LaTeX extractor with file path and maximum section level"""
        self.file_path = file_path
        self.max_level = max_level
        with open(self.file_path, "r", encoding="utf-8") as file:
            self.content = file.read().splitlines()

        # 先识别 codeblock 区间，供后续解析时跳过
        self.codeblocks = self._extract_codeblocks()
        # 便于快速判断某一行是否在 codeblock 内
        self._codeblock_ranges = [(cb["start"], cb["end"]) for cb in self.codeblocks]
        # 起始行 -> 结束行 的映射（仅对 codeblock 有值）
        self._codeblock_end_by_start = {cb["start"]: cb["end"] for cb in self.codeblocks}

        # 再解析章节（会忽略 codeblock 里的 section 等）
        self.sections = self.extract_sections()

    # ---------- 基础工具 ----------

    def _in_codeblock(self, idx):
        """当前行号是否位于任意 codeblock 内"""
        for s, e in self._codeblock_ranges:
            if s <= idx <= e:
                return True
        return False

    def _strip_codeblocks(self, lines):
        """给定若干行文本，去掉 codeblock 区域内的行"""
        out = []
        in_block = False
        for line in lines:
            if (not in_block) and re.search(r"\\begin\{codeblock\}", line):
                in_block = True
                continue
            if in_block and re.search(r"\\end\{codeblock\}", line):
                in_block = False
                continue
            if not in_block:
                out.append(line)
        return out

    # ---------- 代码块解析 ----------

    def _extract_codeblocks(self):
        r"""
        识别 \begin{codeblock}[可选label]{lang} ... \end{codeblock}
        返回列表：[{index, start, end, label, lang, title}]
        其中 title 用于大纲显示，例如：'codeblock 1 [LaTeX代码]{TeX}'
        """
        blocks = []
        in_block = False
        start = -1
        label = ""
        lang = ""
        idx = 0
        counter = 0

        begin_pat = re.compile(r"\\begin\{codeblock\}(?:\[(?P<label>.*?)\])?(?:\{(?P<lang>.*?)\})?")
        end_pat = re.compile(r"\\end\{codeblock\}")

        while idx < len(self.content):
            line = self.content[idx]
            if not in_block:
                m = begin_pat.search(line)
                if m:
                    in_block = True
                    start = idx
                    label = (m.group("label") or "").strip()
                    lang = (m.group("lang") or "").strip()
            else:
                if end_pat.search(line):
                    counter += 1
                    end = idx
                    if label and lang:
                        title = f"codeblock {counter} [{label}]{{{lang}}}"
                    elif label:
                        title = f"codeblock {counter} [{label}]"
                    elif lang:
                        title = f"codeblock {counter} {{{lang}}}"
                    else:
                        title = f"codeblock {counter}"
                    blocks.append(
                        {
                            "index": counter,
                            "start": start,
                            "end": end,
                            "label": label,
                            "lang": lang,
                            "title": title,
                        }
                    )
                    in_block = False
                    start = -1
                    label = ""
                    lang = ""
            idx += 1
        return blocks

    # ---------- 章节解析（忽略 codeblock 内部） ----------

    def extract_sections(self):
        """Extract all sections including type, title, level, and line number"""
        sections = []

        # 先把每个 codeblock 当作一个虚拟 section（level=4）
        for cb in self.codeblocks:
            sections.append(("codeblock", cb["title"], 4, cb["start"]))

        section_types = {
            "section": 1,
            "subsection": 2,
            "subsubsection": 3,
            "numtitle": 4,
            "circtitle": 4,
            "dingtitle": 4,
            "squatitle": 4,
        }
        pattern = re.compile(
            r"\\(section|subsection|subsubsection|numtitle|circtitle|dingtitle|squatitle)(\[\])?\{([^\}]*)\}"
        )

        for i, raw in enumerate(self.content):
            # 跳过 codeblock 内部的任何 \section 等
            if self._in_codeblock(i):
                continue
            line = raw.strip()
            m = pattern.match(line)
            if m:
                section_type = m.group(1)
                title = m.group(3).strip()
                level = section_types[section_type]
                if level <= self.max_level:
                    sections.append((section_type, title, level, i))

        # 维持出现顺序（按照行号排序）
        sections.sort(key=lambda x: x[3])
        return sections

    # ---------- 搜索/提取 ----------

    def find_section(self, pattern):
        """Find section matching the given pattern"""
        for section in self.sections:
            if re.search(pattern, section[1]):
                return section
        return None

    def find_section_startswith(self, pattern):
        """Find section starting with the given pattern"""
        for section_type, title, level, line_num in self.sections:
            if re.match(pattern, title):
                return section_type, title, level, line_num
        return None

    def extract_content(self, start_line, start_level):
        r"""
        Extract content from start line to:
        - next section of same or higher level; or
        - if it's a codeblock item, to its \end{codeblock}
        """
        # 若这是一个 codeblock 节点，直接提取到结束
        if start_line in self._codeblock_end_by_start:
            end_line = self._codeblock_end_by_start[start_line]
            return self.content[start_line : end_line + 1]

        end_line = len(self.content)
        for _, _, level, line_num in self.sections:
            if line_num > start_line and level <= start_level:
                end_line = line_num
                break
        return self.content[start_line:end_line]

    # ---------- 业务相关：问题编号 / 摘要 / 各部分 ----------

    def get_unique_keywords(self):
        """Extract unique problem numbers from Problem Restatement section (skip codeblocks)"""
        keywords = set()
        restate_section = self.find_section(r"问题重述")
        if restate_section:
            _, _, level, line_num = restate_section
            content = self.extract_content(line_num, level)
            # 跳过 codeblock 的内容
            content = self._strip_codeblocks(content)
            pattern = re.compile(r"\\textbf\{问题([一二三四五六七八九十]+)：\}")
            for line in content:
                m = pattern.search(line)
                if m:
                    keywords.add(m.group(1))
        return sorted(list(keywords), key=self.chinese_to_number)

    def chinese_to_number(self, chinese):
        """Convert Chinese numerals to Arabic numbers for sorting"""
        num_dict = {
            "一": 1,
            "二": 2,
            "三": 3,
            "四": 4,
            "五": 5,
            "六": 6,
            "七": 7,
            "八": 8,
            "九": 9,
            "十": 10,
        }
        return num_dict.get(chinese, 0)

    def extract_abstract_parts(self, problem_num):
        """Extract abstract parts: introduction, specific problem, and summary (skip codeblocks)"""
        abstract_content = []
        intro_lines = []
        problem_lines = []
        summary_lines = []
        in_abstract = False
        target_found = False
        in_codeblock = False

        with open(self.file_path, "r", encoding="utf-8") as file:
            for raw in file:
                line = raw.strip()

                # codeblock 屏蔽
                if not in_codeblock and r"\begin{codeblock}" in line:
                    in_codeblock = True
                    continue
                if in_codeblock and r"\end{codeblock}" in line:
                    in_codeblock = False
                    continue
                if in_codeblock:
                    continue

                if r"\begin{abstract}" in line:
                    abstract_content.append(line)
                    in_abstract = True
                elif r"\end{abstract}" in line:
                    abstract_content.append(line)
                    in_abstract = False
                    break
                elif in_abstract:
                    if r"\textbf{针对问题" in line:
                        problem = re.search(r"\\textbf\{针对问题([一二三四五六七八九十]+)\}", line)
                        if problem and problem.group(1) == problem_num:
                            problem_lines.append(line)
                            target_found = True
                        elif target_found:
                            target_found = False
                    elif r"\keywords" in line:
                        summary_lines.append(line)
                        target_found = False
                    elif not problem_lines and not summary_lines:
                        intro_lines.append(line)
                    elif target_found:
                        problem_lines.append(line)
                    elif problem_lines and not target_found:
                        summary_lines.append(line)

        return abstract_content[:1] + intro_lines + problem_lines + summary_lines + abstract_content[-1:]

    def extract_problem_parts(self, problem_num):
        """Extract problem restatement, analysis, and modeling parts (skip codeblocks when scanning)"""
        parts = {}

        # Extract Problem Restatement
        restate_section = self.find_section(r"问题重述")
        if restate_section:
            _, _, level, line_num = restate_section
            content = self.extract_content(line_num, level)
            content = self._strip_codeblocks(content)
            restate_lines = [r"\section{问题重述}"]
            in_background = False
            in_restate = False
            in_target_problem = False

            for line in content:
                if r"\subsection{问题背景}" in line:
                    restate_lines.append(line)
                    in_background = True
                    in_restate = False
                elif r"\subsection{问题重述}" in line:
                    restate_lines.append(line)
                    in_background = False
                    in_restate = True
                elif f"\\textbf{{问题{problem_num}：}}" in line:
                    restate_lines.append(line)
                    in_target_problem = True
                    in_background = False
                    in_restate = False
                elif r"\textbf{问题" in line and in_target_problem:
                    in_target_problem = False
                elif in_background or in_restate or in_target_problem:
                    restate_lines.append(line)

            parts["Restatement"] = restate_lines

        # Extract Problem Analysis
        analysis_pattern = f"问题{problem_num}的分析"
        analysis_section = self.find_section(analysis_pattern)
        if analysis_section:
            section_type, title, level, line_num = analysis_section
            # 直接用章节边界提取，内部若含 codeblock 也原样返回（编辑预览更真实）
            parts["Analysis"] = [
                r"\section{问题分析}",
                f"\\{section_type}{{{title}}}",
            ] + self.extract_content(line_num + 1, level)

        # Extract Modeling and Solution
        modeling_pattern = f"问题{problem_num}模型的建立与求解"
        modeling_section = self.find_section(modeling_pattern)
        if modeling_section:
            section_type, title, level, line_num = modeling_section
            parts["Modeling"] = [
                r"\section{模型建立与求解}",
                f"\\{section_type}{{{title}}}",
            ] + self.extract_content(line_num + 1, level)

        return parts

    def extract_section(self, section_title):
        """Extract complete content of a specified top-level section"""
        for section_type, title, level, line_num in self.sections:
            if title == section_title and level == 1:
                return self.extract_content(line_num, level)
        return []

    # ---------- 保存 ----------

    def save_to_file(self, content, output_file):
        """Save content to file"""
        try:
            with open(output_file, "w", encoding="utf-8") as file:
                file.writelines(line + "\n" for line in content)
        except Exception as e:
            raise IOError(f"无法保存文件: {e}")


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\model\text_replacer.py 的内容:
================================================================================
# %% model/text_replacer.py
# -*- coding: utf-8 -*-

import re


def find_marker_pairs(text):
    marker_pattern = r"(<-----.*?----->)"
    matches = list(re.finditer(marker_pattern, text, re.DOTALL))
    if len(matches) % 2 != 0:
        print("警告：标记数量为奇数，可能存在未配对的标记。")
        return []

    marker_pairs = []
    for i in range(0, len(matches), 2):
        start_marker = matches[i]
        end_marker = matches[i + 1]
        if start_marker.group(1) != end_marker.group(1):
            print(f"警告：标记对不匹配：{start_marker.group(1)} 和 {end_marker.group(1)}")
            continue
        start_pos = start_marker.end()
        end_pos = end_marker.start()
        content = text[start_pos:end_pos]
        marker_pairs.append(
            {
                "index": i // 2,
                "marker_type": start_marker.group(1),
                "content": content,
                "start": start_marker.start(),
                "end": end_marker.end(),
            }
        )
    return marker_pairs


def replace_contents(text, replacements=None):
    if replacements is None:
        replacements = {}
    marker_pairs = find_marker_pairs(text)
    if not marker_pairs:
        return text

    new_text = text
    offset = 0
    for pair in marker_pairs:
        index = pair["index"]
        if index in replacements:
            new_content = replacements[index]
            marker_type = pair["marker_type"]
            replacement = f"{marker_type}\n{new_content}\n{marker_type}"
            original_length = pair["end"] - pair["start"]
            new_start_pos = pair["start"] + offset
            new_end_pos = pair["end"] + offset
            new_text = new_text[:new_start_pos] + replacement + new_text[new_end_pos:]
            offset += len(replacement) - original_length
    return new_text


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\service\agents\mathmodelagent_client.py 的内容:
================================================================================
# %% mathmodelagent_client.py
# -*- coding: utf-8 -*-

"""
mathmodelagent_client.py — 使用 websocket-client 的简洁稳定版客户端
=================================================================

特性
----
- 依赖 `websocket-client`（而非已弃用/冷门的 `websocket` + gevent）。
- 线程安全，内置自动重连（指数退避），并支持心跳 Ping 保活。
- 统一回调：on_open / on_message / on_error / on_close / on_reconnect。
- 同步/异步两种发送：
  - send_json / send_text：异步发送，不等待结果；
  - request()：带 `request_id` 的同步请求，等待指定超时的对应响应。
- 支持 Token 认证（可在 Header 中带入 Authorization），HTTP 代理，TLS 自定义。
- 仅标准库 + websocket-client，无额外依赖。

安装
----
    pip install websocket-client

最简示例
--------
```python
from mathmodelagent_client import MathModelAgentClient

client = MathModelAgentClient(
    url="wss://your-agent-server/ws",
    token="YOUR_TOKEN",              # 可选
)

# 绑定消息回调（可选）
@client.on_message
def _on_msg(message: dict | str):
    print("[MSG]", message)

client.connect(block=False)  # 后台线程运行

# 异步发送
client.send_json({"type": "ping"})

# 同步请求-响应（带 request_id）
resp = client.request({"type": "infer", "payload": {"text": "hello"}}, timeout=15.0)
print("sync resp:", resp)

client.close()
```

与后端协议约定
--------------
- 默认以 JSON 通信，消息结构建议：
  - 请求：`{"request_id": "uuid", "type": "...", "payload": {...}}`
  - 响应：`{"request_id": "uuid", "ok": true, "data": {...}}`
- 若返回为纯文本，客户端会原样转交。

注意
----
- 若你的后端不是以上 JSON 协议，请在 `parse_message`/`_route_response` 按需调整。
- Windows/conda 环境无需 gevent/zope 依赖。
"""
from __future__ import annotations

import json
import logging
import ssl
import threading
import time
import uuid
from dataclasses import dataclass, field
from typing import Any, Callable, Dict, Optional

import websocket  # 来自 websocket-client 包


# ------------------------- 日志配置（可按需接入你项目的 logger） -------------------------
logger = logging.getLogger(__name__)
if not logger.handlers:
    _h = logging.StreamHandler()
    _fmt = logging.Formatter("%(asctime)s [%(levelname)s] %(name)s: %(message)s")
    _h.setFormatter(_fmt)
    logger.addHandler(_h)
logger.setLevel(logging.INFO)


# ------------------------------- 内部数据结构 -------------------------------
@dataclass
class _PendingRequest:
    event: threading.Event = field(default_factory=threading.Event)
    response: Any | None = None
    error: Exception | None = None


# ------------------------------- 主客户端类 -------------------------------
class MathModelAgentClient:
    def __init__(
        self,
        url: str,
        token: Optional[str] = None,
        headers: Optional[Dict[str, str]] = None,
        proxy: Optional[str] = None,
        ping_interval: float = 20.0,
        ping_timeout: float = 10.0,
        reconnect: bool = True,
        max_reconnect_delay: float = 60.0,
        sslopt: Optional[Dict[str, Any]] = None,
    ) -> None:
        """
        :param url: WebSocket 服务地址，例如 wss://host:port/ws
        :param token: 可选的 Bearer Token，会以 Authorization 头发送
        :param headers: 额外 HTTP 头
        :param proxy: 代理地址，例如 http://127.0.0.1:7890
        :param ping_interval: 心跳间隔（秒）；<=0 关闭心跳
        :param ping_timeout: 心跳超时（秒）
        :param reconnect: 网络异常/断线自动重连
        :param max_reconnect_delay: 自动重连的最大退避时间
        :param sslopt: 传入 websocket-client 的 sslopt，例如 {"cert_reqs": ssl.CERT_NONE}
        """
        self.url = url
        self.token = token
        self.base_headers = headers or {}
        self.proxy = proxy
        self.ping_interval = ping_interval
        self.ping_timeout = ping_timeout
        self.reconnect = reconnect
        self.max_reconnect_delay = max_reconnect_delay
        self.sslopt = sslopt or {"cert_reqs": ssl.CERT_REQUIRED}

        # 回调
        self._on_open_cb: Optional[Callable[[], None]] = None
        self._on_message_cb: Optional[Callable[[Any], None]] = None
        self._on_error_cb: Optional[Callable[[Exception], None]] = None
        self._on_close_cb: Optional[Callable[[int, str], None]] = None
        self._on_reconnect_cb: Optional[Callable[[int, float], None]] = None

        # 基础状态
        self._wsapp: Optional[websocket.WebSocketApp] = None
        self._thread: Optional[threading.Thread] = None
        self._stop_event = threading.Event()
        self._connected = threading.Event()

        # 同步请求映射表
        self._pending: Dict[str, _PendingRequest] = {}
        self._pending_lock = threading.Lock()

    # ---------------------------- 装饰器形式绑定回调 ----------------------------
    def on_open(self, func: Callable[[], None]):
        self._on_open_cb = func
        return func

    def on_message(self, func: Callable[[Any], None]):
        self._on_message_cb = func
        return func

    def on_error(self, func: Callable[[Exception], None]):
        self._on_error_cb = func
        return func

    def on_close(self, func: Callable[[int, str], None]):
        self._on_close_cb = func
        return func

    def on_reconnect(self, func: Callable[[int, float], None]):
        """当触发自动重连时调用；参数为 (attempt, delay_seconds)。"""
        self._on_reconnect_cb = func
        return func

    # --------------------------------- 连接管理 ---------------------------------
    def connect(self, block: bool = False) -> None:
        """建立连接。
        :param block: True 则阻塞当前线程直到连接线程结束；False 则后台线程运行。
        """
        self._stop_event.clear()
        self._spawn_ws_thread()
        if block and self._thread is not None:
            self._thread.join()

    def close(self) -> None:
        """优雅关闭连接与线程"""
        self._stop_event.set()
        if self._wsapp is not None:
            try:
                self._wsapp.close()
            except Exception as e:  # noqa
                logger.debug("close error: %s", e)
        if self._thread and self._thread.is_alive():
            self._thread.join(timeout=3)
        self._connected.clear()

    def is_connected(self) -> bool:
        return self._connected.is_set()

    # --------------------------------- 发送 API ---------------------------------
    def send_text(self, text: str) -> None:
        if not self._wsapp:
            raise RuntimeError("WebSocket is not connected")
        self._wsapp.send(text)

    def send_json(self, obj: Dict[str, Any]) -> None:
        self.send_text(json.dumps(obj, ensure_ascii=False))

    def request(self, obj: Dict[str, Any], timeout: float = 10.0) -> Any:
        """同步请求-响应：附加 request_id 并阻塞等待对应响应或超时。
        要求后端在响应中原样返回 `request_id` 字段。
        """
        req_id = obj.get("request_id") or str(uuid.uuid4())
        obj["request_id"] = req_id

        pend = _PendingRequest()
        with self._pending_lock:
            self._pending[req_id] = pend

        try:
            self.send_json(obj)
        except Exception as e:  # 发送失败
            with self._pending_lock:
                self._pending.pop(req_id, None)
            raise e

        ok = pend.event.wait(timeout=timeout)
        with self._pending_lock:
            self._pending.pop(req_id, None)
        if not ok:
            raise TimeoutError(f"request timeout: {req_id}")
        if pend.error:
            raise pend.error
        return pend.response

    # --------------------------------- 内部逻辑 ---------------------------------
    def _spawn_ws_thread(self) -> None:
        if self._thread and self._thread.is_alive():
            return
        t = threading.Thread(target=self._run_forever, name="MathModelAgentWS", daemon=True)
        t.start()
        self._thread = t

    def _build_headers(self) -> list[str]:
        headers = []
        merged = dict(self.base_headers)
        if self.token:
            merged.setdefault("Authorization", f"Bearer {self.token}")
        # 明确 JSON
        merged.setdefault("Content-Type", "application/json")
        for k, v in merged.items():
            headers.append(f"{k}: {v}")
        return headers

    def _run_forever(self) -> None:
        attempt = 0
        backoff = 1.0
        while not self._stop_event.is_set():
            try:
                self._wsapp = websocket.WebSocketApp(
                    self.url,
                    header=self._build_headers(),
                    on_open=self._on_open,
                    on_message=self._on_message,
                    on_error=self._on_error,
                    on_close=self._on_close,
                    on_pong=self._on_pong,
                )

                # 代理拆分
                http_proxy_host = http_proxy_port = None
                if self.proxy:
                    try:
                        scheme, rest = self.proxy.split("://", 1)
                        host_port = rest.split("/", 1)[0]
                        host, port = host_port.split(":", 1)
                        http_proxy_host = host
                        http_proxy_port = int(port)
                    except Exception:  # noqa
                        logger.warning("proxy format invalid, expecting http://host:port")

                # 连接并阻塞，直到 close
                self._connected.clear()
                self._wsapp.run_forever(
                    sslopt=self.sslopt,
                    http_proxy_host=http_proxy_host,
                    http_proxy_port=http_proxy_port,
                    ping_interval=self.ping_interval if self.ping_interval > 0 else None,
                    ping_timeout=self.ping_timeout if self.ping_interval > 0 else None,
                )
            except Exception as e:
                logger.error("WebSocket error: %s", e)
                self._connected.clear()

            if not self.reconnect or self._stop_event.is_set():
                break

            # 自动重连
            attempt += 1
            delay = min(backoff, self.max_reconnect_delay)
            if self._on_reconnect_cb:
                try:
                    self._on_reconnect_cb(attempt, delay)
                except Exception:  # noqa
                    pass
            logger.info("reconnecting in %.1fs (attempt %d)", delay, attempt)
            self._sleep(delay)
            backoff = min(backoff * 2, self.max_reconnect_delay)

    # ----------------------------- WebSocket 回调 -----------------------------
    def _on_open(self, ws: websocket.WebSocketApp):  # noqa: ARG002
        self._connected.set()
        logger.info("WebSocket connected: %s", self.url)
        if self._on_open_cb:
            try:
                self._on_open_cb()
            except Exception as e:
                logger.debug("on_open callback error: %s", e)

    def _on_message(self, ws: websocket.WebSocketApp, message: str | bytes):  # noqa: ARG002
        try:
            parsed = self.parse_message(message)
            self._route_response(parsed)
            if self._on_message_cb:
                self._on_message_cb(parsed)
        except Exception as e:
            logger.error("on_message error: %s", e)

    def _on_error(self, ws: websocket.WebSocketApp, error: Exception):  # noqa: ARG002
        logger.error("WebSocket error: %s", error)
        if self._on_error_cb:
            try:
                self._on_error_cb(error)
            except Exception:  # noqa
                pass

    def _on_close(self, ws: websocket.WebSocketApp, status_code: int, msg: str):  # noqa: ARG002
        self._connected.clear()
        logger.info("WebSocket closed (%s): %s", status_code, msg)
        if self._on_close_cb:
            try:
                self._on_close_cb(status_code, msg)
            except Exception:  # noqa
                pass

    def _on_pong(self, ws: websocket.WebSocketApp, data: str | bytes):  # noqa: ARG002
        logger.debug("< PONG %s", data)

    # ----------------------------- 解析与路由 -----------------------------
    def parse_message(self, message: str | bytes) -> Any:
        """将原始消息解析为 Python 对象。优先按 JSON 解析，不是 JSON 则返回原始文本/二进制。"""
        if isinstance(message, (bytes, bytearray)):
            try:
                return json.loads(message.decode("utf-8"))
            except Exception:
                return message  # 二进制按原样返回
        # str
        try:
            return json.loads(message)
        except Exception:
            return message

    def _route_response(self, payload: Any) -> None:
        """若是带 request_id 的响应，唤醒对应等待的 request()；否则忽略，由 on_message 处理。"""
        if not isinstance(payload, dict):
            return
        req_id = payload.get("request_id")
        if not req_id:
            return
        with self._pending_lock:
            pend = self._pending.get(req_id)
        if pend is None:
            return
        # 认为这是同步响应
        if payload.get("ok") is False and "error" in payload:
            pend.error = RuntimeError(str(payload["error"]))
        else:
            pend.response = payload
        pend.event.set()

    # --------------------------------- 工具 ---------------------------------
    @staticmethod
    def _sleep(seconds: float) -> None:
        try:
            time.sleep(seconds)
        except KeyboardInterrupt:
            pass


# ----------------------------- 可选：简单 CLI -----------------------------
if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="MathModelAgent WebSocket Client")
    parser.add_argument("url", help="wss://host/ws")
    parser.add_argument("--token", default=None, help="Bearer token")
    parser.add_argument("--proxy", default=None, help="http://host:port")
    parser.add_argument("--ping", type=float, default=20.0, help="ping interval seconds (<=0 to disable)")
    args = parser.parse_args()

    client = MathModelAgentClient(
        url=args.url,
        token=args.token,
        proxy=args.proxy,
        ping_interval=args.ping,
        sslopt={"cert_reqs": ssl.CERT_NONE},  # 如需跳过证书校验（内网自签名），请知晓安全风险
    )

    @client.on_open
    def _opened():
        logger.info("opened -> send hello")
        client.send_json({"type": "hello", "ts": time.time()})

    @client.on_message
    def _msg(m):
        logger.info("< %s", m)

    @client.on_reconnect
    def _reconn(attempt, delay):
        logger.info("reconnect attempt=%d delay=%.1fs", attempt, delay)

    client.connect(block=True)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\utils\clear_pycache.py 的内容:
================================================================================
# %% utils/clear_pycache.py
# -*- coding: utf-8 -*-

import os
import shutil


def clear_pycache(root_dir="."):
    for dirpath, dirnames, _ in os.walk(root_dir):
        for dirname in dirnames:
            # 如果是 __pycache__ 文件夹，删除它
            if dirname == "__pycache__":
                dir_to_delete = os.path.join(dirpath, dirname)
                # print(f"Deleting: {dir_to_delete}")
                shutil.rmtree(dir_to_delete)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\utils\paths.py 的内容:
================================================================================
# %% utils/paths.py
# -*- coding: utf-8 -*-

import os
import sys


def resource_path(*parts: str) -> str:
    """
    统一获取资源文件路径：
    - 打包后（PyInstaller --onefile）：使用 sys._MEIPASS 作为资源根目录
    - 开发环境：使用项目根目录（即本文件所在的 utils 目录的上一级）
    用法：
        resource_path("mcmaa.png")
        resource_path("utils", "template", "CUMCM.template")
    """
    # PyInstaller 在运行时会把打包的资源解压到临时目录 _MEIPASS
    if hasattr(sys, "_MEIPASS"):
        base = sys._MEIPASS  # type: ignore[attr-defined]
    else:
        # 本文件位于 .../utils/paths.py -> 项目根目录是它的上一级
        base = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
    return os.path.join(base, *parts)


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\common_widgets.py 的内容:
================================================================================
# %% view/common_widgets.py
# -*- coding: utf-8 -*-

# 内置库
from tkinter import *
import tkinter.filedialog as filedialog
from tkinter.scrolledtext import ScrolledText
import tkinter.messagebox as messagebox

# 第三方库
import ttkbootstrap as ttk


class TextWidget(ttk.Frame):
    def __init__(self, master, on_info=None, **kwargs):
        """
        文本小组件：
        - 带滚动条的可编辑文本框
        - 常用快捷键：撤销/全选/另存为（支持 Win/Linux 的 Ctrl 与 macOS 的 Command）
        :param master: 父容器
        :param on_info: 可选的回调函数，形如 on_info(msg: str)，用于显示提示信息
        :param kwargs: 传给 ttk.Frame 的其他参数
        """
        super().__init__(master, **kwargs)
        self.on_info = on_info

        # 创建可滚动的文本框，启用撤销功能
        self.textbox = ScrolledText(self, undo=True)
        self.textbox.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 设置文本框为可编辑状态
        self.textbox.config(state="normal")

        # 绑定快捷键（Win/Linux: Ctrl，macOS: Command）
        self.textbox.bind("<Control-z>", lambda event: self.textbox.edit_undo())  # Ctrl+Z 撤销
        self.textbox.bind("<Command-z>", lambda event: self.textbox.edit_undo())  # ⌘Z 撤销
        self.textbox.bind("<Control-Shift-s>", lambda event: self.save_as())  # Ctrl+Shift+S 另存为
        self.textbox.bind("<Command-Shift-s>", lambda event: self.save_as())  # ⌘⇧S 另存为
        self.textbox.bind("<Control-a>", self.select_all)  # Ctrl+A 全选
        self.textbox.bind("<Command-a>", self.select_all)  # ⌘A 全选

    def append(self, s):
        """清空并写入内容"""
        self.textbox.delete(1.0, "end")
        self.textbox.insert("end", s)

    def clear(self):
        """清空内容"""
        self.textbox.delete(1.0, "end")

    def get_content(self):
        """获取内容（去除末尾换行）"""
        return self.textbox.get(1.0, "end-1c")

    def save_as(self):
        """另存为功能"""
        file_path = filedialog.asksaveasfilename(
            defaultextension=".md",
            filetypes=[("Markdown files", "*.md"), ("All files", "*.*")],
            title="另存为",
        )
        if not file_path:
            return

        # 保存文本框内容到文件
        content = self.get_content()
        try:
            with open(file_path, "w", encoding="utf-8") as file:
                file.write(content)
        except Exception as e:
            messagebox.showerror("保存失败", f"写入文件时出错：\n{e}")
            return

        # 提示成功：优先用回调，其次用消息框
        msg = f"成功：内容已另存为\n{file_path}"
        if callable(self.on_info):
            try:
                self.on_info(msg)
            except Exception:
                # 回调异常时回退到消息框
                messagebox.showinfo("成功", msg)
        else:
            messagebox.showinfo("成功", msg)

    def select_all(self, event=None):
        """全选文本"""
        self.textbox.tag_add("sel", "1.0", "end")
        return "break"  # 阻止默认事件处理


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\config.py 的内容:
================================================================================
# %% view/config.py
# -*- coding: utf-8 -*-

# 内置库
import os


# 全局配置
DATA_CONFIG = {
    "app": None,
    "window": None,
    "screen": None,
    "py_path": os.path.dirname(os.path.abspath(__file__)),
}

SCREEN_CONFIG = {"borderwidth": 5, "relief": "raised"}
MAIN_FRAME_CONFIG = {"borderwidth": 5, "relief": "sunken"}
RAISED_SUBFRAME_CONFIG = {"borderwidth": 1, "relief": "raised"}
FLAT_SUBFRAME_CONFIG = {"borderwidth": 2}
ENTRY_LABEL_CONFIG = {"padding": 2}


================================================================================
E:\repo1\MCM\mcmaa\mcmaa_tk\view\screens\screen_workbench.py 的内容:
================================================================================
# %% view/screens/screen_workbench.py
# -*- coding: utf-8 -*-

from tkinter import *
from tkinter.scrolledtext import ScrolledText
import ttkbootstrap as ttk
import tkinter.filedialog as filedialog
import tkinter.messagebox as messagebox

from ..config import SCREEN_CONFIG, MAIN_FRAME_CONFIG
from controller.workbench_controller import WorkbenchController


class Screen_Workbench(ttk.Frame):
    """
    一体化工作台（MVC：View）
    - 左侧：导航（大纲/问题/代码）
    - 右侧：Notebook（编辑 / 预览 / 替换 / 辅助）
    - 文件快捷键：Ctrl+O 打开；Ctrl+S 保存（替换页为“应用替换”）
    - Ctrl+F 全文搜索；Ctrl+H 全文替换
    - 业务逻辑均委托给 WorkbenchController
    """

    MODE_NAME = "一体化工作台"

    # ---------- 对外给菜单用的 API ----------
    def get_recent_files(self):
        """给主菜单调用，获取最近文件列表（最新在前）"""
        return list(self.ctrl.recent_files)

    def quick_open(self, p):
        """给主菜单的 Quick Open 点击使用（委托 Controller，文案由 View 负责）"""
        ok, _msg, text = self.ctrl.quick_open(p)
        if not ok:
            messagebox.showwarning("提示", "文件不存在，已从最近列表移除。")
            return
        self.editor.delete(1.0, "end")
        self.editor.insert("end", text)
        self.set_preview(f"文件已加载: {p}")
        self._refresh_marker_pairs()
        self._rebuild_all_trees()
        self.notebook.select(self.tab_edit)

    # =====================================================

    def __init__(self, master):
        super().__init__(master, **SCREEN_CONFIG)
        self.place(relx=0, rely=0, relwidth=1, relheight=1)

        # Controller & 轻量状态
        self.ctrl = WorkbenchController()
        self.selected_pair_display = StringVar(value="")

        # ===== 主左右分割 =====
        main_paned = ttk.PanedWindow(self, orient="horizontal")
        main_paned.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 左侧：导航（大纲/问题/代码）
        left_frame = ttk.Frame(main_paned, **MAIN_FRAME_CONFIG)
        main_paned.add(left_frame, weight=30)
        self.left_tabs = ttk.Notebook(left_frame)
        self.left_tabs.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 大纲
        self.outline_tab = ttk.Frame(self.left_tabs)
        self.left_tabs.add(self.outline_tab, text="大纲")
        self.outline_tree = ttk.Treeview(self.outline_tab, show="tree")
        self.outline_tree.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.outline_tree.bind("<<TreeviewSelect>>", self.on_outline_select)
        self.outline_tree.bind("<Double-1>", self._goto_outline_line)

        # 问题（含右键菜单）
        self.problem_tab = ttk.Frame(self.left_tabs)
        self.left_tabs.add(self.problem_tab, text="问题")
        self.problem_tree = ttk.Treeview(self.problem_tab, show="tree")
        self.problem_tree.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.problem_tree.bind("<<TreeviewSelect>>", self.on_problem_select)
        self._init_problem_context_menu()

        # 代码（专门放 codeblock）
        self.code_tab = ttk.Frame(self.left_tabs)
        self.left_tabs.add(self.code_tab, text="代码")
        self.code_tree = ttk.Treeview(self.code_tab, show="tree")
        self.code_tree.place(relx=0, rely=0, relwidth=1, relheight=1)
        self.code_tree.bind("<<TreeviewSelect>>", self.on_code_select)

        # 右侧：Notebook（编辑/预览/替换/辅助）
        right_frame = ttk.Frame(main_paned, **MAIN_FRAME_CONFIG)
        main_paned.add(right_frame, weight=70)
        self.notebook = ttk.Notebook(right_frame)
        self.notebook.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 编辑
        self.tab_edit = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_edit, text="编辑")
        self.editor = ScrolledText(self.tab_edit, wrap="none", undo=True)
        self.editor.place(relx=0, rely=0, relwidth=1, relheight=1)
        # 快捷键（Win/Linux: Ctrl，macOS: Command）
        self.editor.bind("<Control-a>", lambda e: self._select_all(self.editor))
        self.editor.bind("<Control-s>", lambda e: (self.save_current_text(), "break"))
        self.editor.bind("<Control-o>", lambda e: (self.select_file(), "break"))
        self.editor.bind("<Control-f>", lambda e: (self._open_find_dialog(), "break"))
        self.editor.bind("<Control-h>", lambda e: (self._open_replace_dialog(), "break"))
        self.editor.bind("<Command-a>", lambda e: self._select_all(self.editor))
        self.editor.bind("<Command-s>", lambda e: (self.save_current_text(), "break"))
        self.editor.bind("<Command-o>", lambda e: (self.select_file(), "break"))
        self.editor.bind("<Command-f>", lambda e: (self._open_find_dialog(), "break"))
        self.editor.bind("<Command-h>", lambda e: (self._open_replace_dialog(), "break"))

        # 预览
        self.tab_preview = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_preview, text="预览")
        self.preview = ScrolledText(self.tab_preview, wrap="word", state="disabled")
        self.preview.place(relx=0, rely=0, relwidth=1, relheight=1)

        # 替换
        self.tab_replace = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_replace, text="替换")

        topbar = ttk.Frame(self.tab_replace, padding=(8, 6))
        topbar.pack(side="top", fill="x")

        ttk.Label(topbar, text="标记对：").pack(side="left")
        self.pair_combo = ttk.Combobox(topbar, textvariable=self.selected_pair_display, state="readonly", width=40)
        self.pair_combo.pack(side="left", padx=(6, 8), fill="x", expand=True)
        self.pair_combo.bind("<<ComboboxSelected>>", lambda e: self.on_pair_select())

        apply_btn = ttk.Button(topbar, text="应用替换（Ctrl+S）", bootstyle="primary", command=self.apply_replace)
        apply_btn.pack(side="right")

        # 中部输入框：占满剩余空间
        self.replace_input = ScrolledText(self.tab_replace, wrap="word")
        self.replace_input.pack(side="top", fill="both", expand=True)
        self.replace_input.bind("<Control-a>", self._select_all)
        self.replace_input.bind("<Command-a>", self._select_all)

        # 全局 Ctrl/⌘+S：替换页=应用替换；辅助页=插入；其它页=保存
        self.bind_all("<Control-s>", self._on_global_save_or_apply)
        self.bind_all("<Command-s>", self._on_global_save_or_apply)

        # 进入“替换”页时自动扫描标记对
        self.notebook.bind("<<NotebookTabChanged>>", self._maybe_refresh_pairs)

        # ===== 辅助页 =====
        self.tab_aid = ttk.Frame(self.notebook)
        self.notebook.add(self.tab_aid, text="辅助")

        aid_top = ttk.Frame(self.tab_aid, padding=(8, 6))
        aid_top.pack(side="top", fill="x")

        ttk.Label(aid_top, text="辅助文件：").pack(side="left")
        self.aid_selected = ttk.StringVar(value="")
        self.aid_combo = ttk.Combobox(aid_top, textvariable=self.aid_selected, state="readonly", width=46)
        self.aid_combo.pack(side="left", padx=(6, 8), fill="x", expand=True)
        self.aid_combo.bind("<<ComboboxSelected>>", lambda e: self._on_aid_select())

        aid_apply_btn = ttk.Button(
            aid_top, text="插入到编辑器（Ctrl+S）", bootstyle="secondary", command=self.apply_aid_to_editor
        )
        aid_apply_btn.pack(side="right")

        self.aid_view = ScrolledText(self.tab_aid, wrap="word")
        self.aid_view.pack(side="top", fill="both", expand=True)
        self.aid_view.bind("<Control-a>", self._select_all)
        self.aid_view.bind("<Command-a>", self._select_all)

        # 切换到“辅助”页时刷新文件列表
        def _maybe_refresh_aid(_evt=None):
            try:
                if self.notebook.tab(self.notebook.select(), "text") == "辅助":
                    self._refresh_aid_files()
            except Exception:
                pass

        self.notebook.bind("<<NotebookTabChanged>>", _maybe_refresh_aid)
        self._refresh_aid_files()

    # ---------- 辅助页：文件列表/读取/插入 ----------
    def _aid_dir_path(self):
        return self.ctrl.aid_dir()

    def _refresh_aid_files(self):
        files = self.ctrl.list_aid_txt()
        self.aid_combo["values"] = files
        if not files:
            self.aid_selected.set("")
            self.aid_view.delete(1.0, "end")
        else:
            cur = self.aid_selected.get()
            if cur not in files:
                self.aid_selected.set(files[0])
            self._on_aid_select()

    def _on_aid_select(self):
        fname = self.aid_selected.get().strip()
        self.aid_view.delete(1.0, "end")
        if not fname:
            return
        try:
            txt = self.ctrl.read_aid_txt(fname)
        except Exception as e:
            txt = f"(读取失败：{e})"
        self.aid_view.insert("end", txt)

    def apply_aid_to_editor(self):
        """
        将辅助区当前内容插入编辑器：
        - 若编辑器有选区：替换选区
        - 否则：在光标处插入
        """
        content = self.aid_view.get(1.0, "end-1c")
        self.notebook.select(self.tab_edit)
        self.editor.focus_set()
        try:
            try:
                sel_start = self.editor.index("sel.first")
                sel_end = self.editor.index("sel.last")
                self.editor.delete(sel_start, sel_end)
                self.editor.insert(sel_start, content)
                self.editor.mark_set(INSERT, f"{sel_start}+{len(content)}c")
            except Exception:
                self.editor.insert(INSERT, content)
                self.editor.mark_set(INSERT, f"insert+{len(content)}c")
        except Exception as e:
            messagebox.showerror("错误", f"插入失败：{e}")

    # ---------------- 工具函数 ----------------
    def _select_all(self, target=None):
        """
        支持两种调用方式：
        1) 作为事件回调：_select_all(event)
        2) 直接传控件：_select_all(widget)
        """
        widget = None
        if hasattr(target, "widget"):
            widget = target.widget
        elif target is not None:
            widget = target
        else:
            return "break"
        try:
            widget.tag_add("sel", "1.0", "end")
        except Exception:
            pass
        return "break"

    def _get_editor_text(self):
        return self.editor.get(1.0, "end-1c")

    def set_preview(self, text):
        self.notebook.select(self.tab_preview)
        self.preview.config(state="normal")
        self.preview.delete(1.0, "end")
        self.preview.insert("end", text)
        self.preview.config(state="disabled")

    # 全局保存/应用的统一入口
    def _on_global_save_or_apply(self, _event=None):
        """替换页 Ctrl/⌘+S 应用替换；辅助页插入；其它页保存文件"""
        try:
            tab_text = self.notebook.tab(self.notebook.select(), "text")
        except Exception:
            tab_text = ""
        if tab_text == "替换":
            self.apply_replace()
        elif tab_text == "辅助":
            self.apply_aid_to_editor()
        else:
            self.save_current_text()
        return "break"

    # ---------------- 文件 I/O（快捷键驱动） ----------------
    def reload_from_disk(self):
        """从磁盘重载，不改动文件内容"""
        data = self.ctrl.reload_from_disk()
        text = data.get("text", "")
        if not text:
            return
        self.editor.delete(1.0, "end")
        self.editor.insert("end", text)
        self._refresh_marker_pairs()
        self._rebuild_all_trees()
        self.set_preview("已从磁盘重载。")

    def select_file(self):
        file_path = filedialog.askopenfilename(
            title="选择 LaTeX 文件",
            filetypes=[("LaTeX files", "*.tex"), ("LaTeX Template files", "*.template"), ("All files", "*.*")],
        )
        if not file_path:
            return
        self._open_path(file_path)

    def _open_path(self, file_path):
        try:
            data = self.ctrl.open_path(file_path)
            text = data["text"]
            self.editor.delete(1.0, "end")
            self.editor.insert("end", text)
            self.set_preview(f"文件已加载: {file_path}")
            self._refresh_marker_pairs()
            self._rebuild_all_trees()
            self.notebook.select(self.tab_edit)
        except Exception as e:
            self.set_preview(f"错误: {e}")

    def save_current_text(self):
        ok, msg = self.ctrl.save_text(self._get_editor_text())
        if not ok:
            self.set_preview(f"保存失败：{msg or '未知错误'}")
            return
        self._rebuild_all_trees()
        self.set_preview("保存成功。")

    # ---------------- 解析 / 导航 ----------------
    def _rebuild_all_trees(self):
        self._build_outline_tree()
        self._build_problem_tree()
        self._build_code_tree()

    def _build_outline_tree(self):
        self.outline_tree.delete(*self.outline_tree.get_children())
        if not self.ctrl.extractor:
            return

        nodes = self.ctrl.make_outline_nodes(self.ctrl.extractor)
        stack = [("", 0)]  # [(tk_node_id, level)]
        for n in nodes:
            title, level, line_num = n["title"], n["level"], n["line_num"]
            while stack and level <= stack[-1][1]:
                stack.pop()
            parent = stack[-1][0] if stack else ""
            node_id = self.outline_tree.insert(parent, "end", text=title, values=(line_num, level))
            stack.append((node_id, level))

    def _build_problem_tree(self):
        self.problem_tree.delete(*self.problem_tree.get_children())
        if not self.ctrl.extractor:
            return
        items = self.ctrl.make_problem_tree(self.ctrl.extractor)
        for item in items:
            pnode = self.problem_tree.insert("", "end", text=item["text"], values=item["values"])
            for child in item.get("children", []):
                self.problem_tree.insert(pnode, "end", text=child["text"], values=child["values"])

    def _build_code_tree(self):
        self.code_tree.delete(*self.code_tree.get_children())
        if not self.ctrl.extractor:
            return
        nodes = self.ctrl.make_code_nodes(self.ctrl.extractor)
        for n in nodes:
            self.code_tree.insert("", "end", text=n["text"], values=n["values"])

    # ---------------- 问题树：右键菜单 ----------------
    def _init_problem_context_menu(self):
        self.problem_menu = ttk.Menu(self.problem_tree, tearoff=False)
        self.problem_menu.add_command(label="复制该问题：摘要+重述+分析+建模", command=self._copy_problem_merged)
        self.problem_menu.add_separator()
        self.problem_menu.add_command(label="只复制 摘要片段", command=lambda: self._copy_problem_part("abstract"))
        self.problem_menu.add_command(label="只复制 问题重述", command=lambda: self._copy_problem_part("restate"))
        self.problem_menu.add_command(label="只复制 问题分析", command=lambda: self._copy_problem_part("analysis"))
        self.problem_menu.add_command(label="只复制 模型与求解", command=lambda: self._copy_problem_part("modeling"))
        self.problem_tree.bind("<Button-3>", self._popup_problem_menu)

    def _popup_problem_menu(self, event):
        try:
            iid = self.problem_tree.identify_row(event.y)
            if iid:
                self.problem_tree.selection_set(iid)
                self.problem_menu.tk_popup(event.x_root, event.y_root)
        finally:
            self.problem_menu.grab_release()

    def _copy_to_clipboard(self, s):
        try:
            top = self.winfo_toplevel()
            top.clipboard_clear()
            top.clipboard_append(s)
            top.update_idletasks()
        except Exception:
            pass

    def _copy_problem_merged(self):
        item = self.problem_tree.focus()
        vals = self.problem_tree.item(item, "values")
        if not vals:
            return
        k = vals[0] if len(vals) >= 1 else None
        if not k:
            return
        text = self.ctrl.build_problem_merged_text(self.ctrl.extractor, k)
        if text:
            self._copy_to_clipboard(text)

    def _copy_problem_part(self, part):
        item = self.problem_tree.focus()
        vals = self.problem_tree.item(item, "values")
        if not vals:
            return
        k = vals[0]
        text = self.ctrl.build_problem_part_text(self.ctrl.extractor, k, part)
        if text:
            self._copy_to_clipboard(text)

    # ---------------- 导航事件 ----------------
    def on_outline_select(self, _event):
        if not self.ctrl.extractor:
            return
        item = self.outline_tree.focus()
        vals = self.outline_tree.item(item, "values")
        if not vals:
            return
        line_num, section_level = map(int, vals)
        text = self.ctrl.render_outline_preview(self.ctrl.extractor, line_num, section_level)
        self.set_preview(text)

    def _goto_outline_line(self, _event=None):
        """双击大纲项，编辑器跳转到对应行，并临时高亮"""
        item = self.outline_tree.focus()
        vals = self.outline_tree.item(item, "values")
        if not vals:
            return
        line_num = int(vals[0]) + 1  # Tk 文本行号从 1 开始
        self.notebook.select(self.tab_edit)
        idx = f"{line_num}.0"
        self.editor.see(idx)
        self.editor.mark_set("insert", idx)
        self.editor.tag_configure("goto_flash", background="#a5d6a7")
        self.editor.tag_add("goto_flash", idx, f"{line_num}.end")
        self.editor.after(2000, lambda: self.editor.tag_delete("goto_flash"))

    def on_problem_select(self, _event):
        if not self.ctrl.extractor:
            return
        item = self.problem_tree.focus()
        vals = self.problem_tree.item(item, "values")
        if not vals:
            return
        if len(vals) == 1:  # 点击“问题X” -> View 端合并并加分隔标题（展示层）
            k = vals[0]
            text = self._compose_problem_preview_with_headings(k)
        else:
            k, part = vals
            body = self.ctrl.build_problem_part_text(self.ctrl.extractor, k, part)
            title_map = {
                "abstract": "摘要片段",
                "restate": "问题重述",
                "analysis": "问题分析",
                "modeling": "模型与求解",
            }
            header = f"% ===== {title_map.get(part, part)} =====\n" if body else ""
            text = f"{header}{body}".strip()
        self.set_preview(text)

    def _compose_problem_preview_with_headings(self, k: str) -> str:
        """在 View 侧为合并预览加上分节标题与分隔（纯展示）"""
        pieces = [
            ("摘要片段", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "abstract")),
            ("问题重述", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "restate")),
            ("问题分析", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "analysis")),
            ("模型与求解", self.ctrl.build_problem_part_text(self.ctrl.extractor, k, "modeling")),
        ]
        out = []
        for title, body in pieces:
            if body:
                out.append(f"% ===== {title} =====")
                out.append(body)
                out.append("")
        return "\n".join(out).strip()

    def on_code_select(self, _event):
        if not self.ctrl.extractor:
            return
        item = self.code_tree.focus()
        vals = self.code_tree.item(item, "values")
        if not vals:
            return
        line_num, level = map(int, vals)
        text = self.ctrl.render_code_preview(self.ctrl.extractor, line_num, level)
        self.set_preview(text)

    # ---------------- 替换功能（仅服务标记对） ----------------
    def _maybe_refresh_pairs(self, _evt=None):
        try:
            tab_text = self.notebook.tab(self.notebook.select(), "text")
            if tab_text == "替换":
                self._refresh_marker_pairs()
        except Exception:
            pass

    def _refresh_marker_pairs(self):
        """
        View 只负责：
        - 将当前编辑器文本同步给 Controller（保持业务状态在 Controller）
        - 请求 Controller 扫描并返回可显示的标记对列表
        - 刷新下拉与文本框
        """
        current = self._get_editor_text()
        self.ctrl.update_current_text_only(current)
        display = self.ctrl.update_marker_pairs_from_text(current)
        if hasattr(self, "pair_combo"):
            self.pair_combo["values"] = display
            if display:
                self.selected_pair_display.set(display[0])
                self.on_pair_select()
            else:
                self.selected_pair_display.set("")
                self.replace_input.delete(1.0, "end")

    def on_pair_select(self, *_):
        sel = (self.selected_pair_display.get() or "").strip()
        self.replace_input.delete(1.0, "end")
        if not sel:
            return
        content = self.ctrl.get_pair_content_by_display(sel)
        self.replace_input.insert("end", content)

    def apply_replace(self):
        """
        View 只负责读入 UI 值并将结果写回编辑器；
        具体替换业务由 Controller 完成。
        """
        sel = (self.selected_pair_display.get() or "").strip()
        if not sel:
            return
        try:
            new_content = self.replace_input.get(1.0, "end-1c")
            base_text = self._get_editor_text()
            new_text = self.ctrl.apply_replace_for_display(base_text, sel, new_content)
            self.editor.delete(1.0, "end")
            self.editor.insert("end", new_text)
            self._refresh_marker_pairs()
        except Exception as e:
            messagebox.showerror("错误", f"替换失败: {str(e)}")

    # ---------------- 编辑器：全文搜索 / 替换 ----------------
    def _clear_search_tags(self):
        self.editor.tag_delete("search_hit")
        self.editor.tag_configure("search_hit", background="#ffd54f")

    def _do_find_all(self, needle):
        self._clear_search_tags()
        if not needle:
            return 0
        idx = "1.0"
        count = 0
        while True:
            idx = self.editor.search(needle, idx, nocase=False, stopindex=END)
            if not idx:
                break
            lastidx = f"{idx}+{len(needle)}c"
            self.editor.tag_add("search_hit", idx, lastidx)
            idx = lastidx
            count += 1
        if count:
            self.editor.see("search_hit.first")
        return count

    def _open_find_dialog(self):
        top = Toplevel(self)
        top.title("查找 (Ctrl+F)")
        top.transient(self.winfo_toplevel())
        top.resizable(False, False)

        ttk.Label(top, text="查找内容:").grid(row=0, column=0, padx=8, pady=8, sticky="w")
        var_find = StringVar()
        ttk.Entry(top, textvariable=var_find, width=40).grid(row=0, column=1, padx=8, pady=8)
        msg = ttk.Label(top, text="", bootstyle="secondary")
        msg.grid(row=1, column=0, columnspan=2, padx=8, pady=(0, 8), sticky="w")

        def do_find():
            n = self._do_find_all(var_find.get())
            msg.config(text=f"匹配 {n} 处")

        ttk.Button(top, text="查找全部并高亮", command=do_find).grid(row=0, column=2, padx=8, pady=8)
        top.bind("<Return>", lambda e: do_find())
        top.protocol("WM_DELETE_WINDOW", top.destroy)

    def _open_replace_dialog(self):
        top = Toplevel(self)
        top.title("替换 (Ctrl+H)")
        top.transient(self.winfo_toplevel())
        top.resizable(False, False)

        var_find = StringVar()
        var_repl = StringVar()

        ttk.Label(top, text="查找:").grid(row=0, column=0, padx=8, pady=8, sticky="w")
        e_find = ttk.Entry(top, textvariable=var_find, width=42)
        e_find.grid(row=0, column=1, padx=8, pady=8)
        e_find.focus_set()

        ttk.Label(top, text="替换为:").grid(row=1, column=0, padx=8, pady=8, sticky="w")
        e_repl = ttk.Entry(top, textvariable=var_repl, width=42)
        e_repl.grid(row=1, column=1, padx=8, pady=8)

        msg = ttk.Label(top, text="", bootstyle="secondary")
        msg.grid(row=2, column=0, columnspan=3, padx=8, pady=(0, 8), sticky="w")

        def replace_next():
            needle = var_find.get()
            if not needle:
                return
            idx = self.editor.index(INSERT)
            pos = self.editor.search(needle, idx, nocase=False, stopindex=END)
            if not pos:
                pos = self.editor.search(needle, "1.0", nocase=False, stopindex=END)
                if not pos:
                    msg.config(text="未找到")
                    return
            last = f"{pos}+{len(needle)}c"
            self.editor.delete(pos, last)
            self.editor.insert(pos, var_repl.get())
            self.editor.mark_set(INSERT, f"{pos}+{len(var_repl.get())}c")
            msg.config(text="已替换 1 处")

        def replace_all():
            needle = var_find.get()
            repl = var_repl.get()
            if not needle:
                return
            text = self._get_editor_text()
            count = text.count(needle)
            if count == 0:
                msg.config(text="未找到")
                return
            text = text.replace(needle, repl)
            self.editor.delete(1.0, END)
            self.editor.insert(END, text)
            msg.config(text=f"已替换 {count} 处")

        ttk.Button(top, text="替换下一个", command=replace_next).grid(row=0, column=2, padx=8, pady=8)
        ttk.Button(top, text="全部替换", command=replace_all).grid(row=1, column=2, padx=8, pady=8)

        top.bind("<Return>", lambda e: replace_next())
        top.protocol("WM_DELETE_WINDOW", top.destroy)


